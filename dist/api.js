"use strict";
/**
 * ClickSend v3 API
 *  This is an official SDK for [ClickSend](https://clicksend.com)  Below you will find a current list of the available methods for clicksend.  *NOTE: You will need to create a free account to use the API. You can register [here](https://dashboard.clicksend.com/#/signup/step1/)..*
 *
 * OpenAPI spec version: 3.1
 * Contact: support@clicksend.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceDeliveryReceiptRulesApi = exports.VoiceDeliveryReceiptRulesApiApiKeys = exports.VoiceApi = exports.VoiceApiApiKeys = exports.UserEmailTemplatesApi = exports.UserEmailTemplatesApiApiKeys = exports.UploadApi = exports.UploadApiApiKeys = exports.TransferCreditApi = exports.TransferCreditApiApiKeys = exports.TransactionalEmailApi = exports.TransactionalEmailApiApiKeys = exports.TimezonesApi = exports.TimezonesApiApiKeys = exports.SubaccountApi = exports.SubaccountApiApiKeys = exports.StatisticsApi = exports.StatisticsApiApiKeys = exports.SmsCampaignApi = exports.SmsCampaignApiApiKeys = exports.SearchApi = exports.SearchApiApiKeys = exports.SMSDeliveryReceiptRulesApi = exports.SMSDeliveryReceiptRulesApiApiKeys = exports.SMSApi = exports.SMSApiApiKeys = exports.ResellerAccountApi = exports.ResellerAccountApiApiKeys = exports.ReferralAccountApi = exports.ReferralAccountApiApiKeys = exports.PostReturnAddressApi = exports.PostReturnAddressApiApiKeys = exports.PostPostcardApi = exports.PostPostcardApiApiKeys = exports.PostLetterApi = exports.PostLetterApiApiKeys = exports.NumberApi = exports.NumberApiApiKeys = exports.MmsCampaignApi = exports.MmsCampaignApiApiKeys = exports.MasterEmailTemplatesApi = exports.MasterEmailTemplatesApiApiKeys = exports.MMSApi = exports.MMSApiApiKeys = exports.InboundSMSRulesApi = exports.InboundSMSRulesApiApiKeys = exports.InboundFAXRulesApi = exports.InboundFAXRulesApiApiKeys = exports.FAXDeliveryReceiptRulesApi = exports.FAXDeliveryReceiptRulesApiApiKeys = exports.FAXApi = exports.FAXApiApiKeys = exports.EmailToSmsApi = exports.EmailToSmsApiApiKeys = exports.EmailMarketingApi = exports.EmailMarketingApiApiKeys = exports.EmailDeliveryReceiptRulesApi = exports.EmailDeliveryReceiptRulesApiApiKeys = exports.DetectAddressApi = exports.DetectAddressApiApiKeys = exports.DeliveryIssuesApi = exports.DeliveryIssuesApiApiKeys = exports.CountriesApi = exports.CountriesApiApiKeys = exports.ContactListApi = exports.ContactListApiApiKeys = exports.ContactApi = exports.ContactApiApiKeys = exports.AccountRechargeApi = exports.AccountRechargeApiApiKeys = exports.AccountApi = exports.AccountApiApiKeys = exports.VoidAuth = exports.OAuth = exports.ApiKeyAuth = exports.HttpBasicAuth = exports.VoiceMessageCollection = exports.VoiceMessage = exports.Url = exports.UploadFile = exports.Subaccount = exports.StrippedString = exports.SmsTemplate = exports.SmsMessageCollection = exports.SmsMessage = exports.SmsCampaign = exports.ResellerAccountTransferCredit = exports.ResellerAccount = exports.PostRecipient = exports.PostPostcard = exports.PostLetter = exports.MmsMessageCollection = exports.MmsMessage = exports.MmsCampaign = exports.InboundSMSRule = exports.InboundFaxRule = exports.ForgotUsername = exports.ForgotPassword = exports.FieldsFields = exports.Fields = exports.FaxMessageCollection = exports.FaxMessage = exports.EmailTemplateUpdate = exports.EmailTemplateNew = exports.EmailSMSAddress = exports.EmailRecipient = exports.EmailFrom = exports.EmailCampaign = exports.EmailAddress = exports.Email = exports.DeliveryReceiptRule = exports.DeliveryIssue = exports.DateBefore = exports.CreditCard = exports.ContactListImport = exports.ContactList = exports.Contact = exports.Attachment = exports.Address = exports.AccountVerify = exports.AccountForgotPasswordVerify = exports.Account = void 0;
const localVarRequest = require("request");
let defaultBasePath = 'https://rest.clicksend.com/v3';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
/**
* Complete account details needed for the user.
*/
let Account = /** @class */ (() => {
    class Account {
        static getAttributeTypeMap() {
            return Account.attributeTypeMap;
        }
    }
    Account.discriminator = "classType";
    Account.attributeTypeMap = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "userPhone",
            "baseName": "user_phone",
            "type": "string"
        },
        {
            "name": "userEmail",
            "baseName": "user_email",
            "type": "string"
        },
        {
            "name": "userFirstName",
            "baseName": "user_first_name",
            "type": "string"
        },
        {
            "name": "userLastName",
            "baseName": "user_last_name",
            "type": "string"
        },
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }
    ];
    return Account;
})();
exports.Account = Account;
let AccountForgotPasswordVerify = /** @class */ (() => {
    class AccountForgotPasswordVerify {
        static getAttributeTypeMap() {
            return AccountForgotPasswordVerify.attributeTypeMap;
        }
    }
    AccountForgotPasswordVerify.discriminator = "classType";
    AccountForgotPasswordVerify.attributeTypeMap = [
        {
            "name": "subaccountId",
            "baseName": "subaccount_id",
            "type": "number"
        },
        {
            "name": "activationToken",
            "baseName": "activation_token",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }
    ];
    return AccountForgotPasswordVerify;
})();
exports.AccountForgotPasswordVerify = AccountForgotPasswordVerify;
/**
* Verifies an account by token that should have been sent to the user's phone
*/
let AccountVerify = /** @class */ (() => {
    class AccountVerify {
        static getAttributeTypeMap() {
            return AccountVerify.attributeTypeMap;
        }
    }
    AccountVerify.discriminator = "classType";
    AccountVerify.attributeTypeMap = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "userPhone",
            "baseName": "user_phone",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return AccountVerify;
})();
exports.AccountVerify = AccountVerify;
/**
* Base model for all address-related objects.
*/
let Address = /** @class */ (() => {
    class Address {
        static getAttributeTypeMap() {
            return Address.attributeTypeMap;
        }
    }
    Address.discriminator = "classType";
    Address.attributeTypeMap = [
        {
            "name": "addressName",
            "baseName": "address_name",
            "type": "string"
        },
        {
            "name": "addressLine1",
            "baseName": "address_line_1",
            "type": "string"
        },
        {
            "name": "addressCity",
            "baseName": "address_city",
            "type": "string"
        },
        {
            "name": "addressPostalCode",
            "baseName": "address_postal_code",
            "type": "string"
        },
        {
            "name": "addressCountry",
            "baseName": "address_country",
            "type": "string"
        },
        {
            "name": "addressLine2",
            "baseName": "address_line_2",
            "type": "string"
        },
        {
            "name": "addressState",
            "baseName": "address_state",
            "type": "string"
        }
    ];
    return Address;
})();
exports.Address = Address;
/**
* Email attachment
*/
let Attachment = /** @class */ (() => {
    class Attachment {
        static getAttributeTypeMap() {
            return Attachment.attributeTypeMap;
        }
    }
    Attachment.discriminator = "classType";
    Attachment.attributeTypeMap = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "disposition",
            "baseName": "disposition",
            "type": "string"
        },
        {
            "name": "contentId",
            "baseName": "content_id",
            "type": "string"
        }
    ];
    return Attachment;
})();
exports.Attachment = Attachment;
/**
* Contains all details for the main contact.
*/
let Contact = /** @class */ (() => {
    class Contact {
        static getAttributeTypeMap() {
            return Contact.attributeTypeMap;
        }
    }
    Contact.discriminator = "classType";
    Contact.attributeTypeMap = [
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "custom1",
            "baseName": "custom_1",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "faxNumber",
            "baseName": "fax_number",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "addressLine1",
            "baseName": "address_line_1",
            "type": "string"
        },
        {
            "name": "addressLine2",
            "baseName": "address_line_2",
            "type": "string"
        },
        {
            "name": "addressCity",
            "baseName": "address_city",
            "type": "string"
        },
        {
            "name": "addressState",
            "baseName": "address_state",
            "type": "string"
        },
        {
            "name": "addressPostalCode",
            "baseName": "address_postal_code",
            "type": "string"
        },
        {
            "name": "addressCountry",
            "baseName": "address_country",
            "type": "string"
        },
        {
            "name": "organizationName",
            "baseName": "organization_name",
            "type": "string"
        },
        {
            "name": "custom2",
            "baseName": "custom_2",
            "type": "string"
        },
        {
            "name": "custom3",
            "baseName": "custom_3",
            "type": "string"
        },
        {
            "name": "custom4",
            "baseName": "custom_4",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        }
    ];
    return Contact;
})();
exports.Contact = Contact;
/**
* Your contact list.
*/
let ContactList = /** @class */ (() => {
    class ContactList {
        static getAttributeTypeMap() {
            return ContactList.attributeTypeMap;
        }
    }
    ContactList.discriminator = "classType";
    ContactList.attributeTypeMap = [
        {
            "name": "listName",
            "baseName": "list_name",
            "type": "string"
        }
    ];
    return ContactList;
})();
exports.ContactList = ContactList;
/**
* Contact list import model
*/
let ContactListImport = /** @class */ (() => {
    class ContactListImport {
        static getAttributeTypeMap() {
            return ContactListImport.attributeTypeMap;
        }
    }
    ContactListImport.discriminator = "classType";
    ContactListImport.attributeTypeMap = [
        {
            "name": "fileUrl",
            "baseName": "file_url",
            "type": "string"
        },
        {
            "name": "fieldOrder",
            "baseName": "field_order",
            "type": "Array<string>"
        }
    ];
    return ContactListImport;
})();
exports.ContactListImport = ContactListImport;
/**
* Credit card model
*/
let CreditCard = /** @class */ (() => {
    class CreditCard {
        static getAttributeTypeMap() {
            return CreditCard.attributeTypeMap;
        }
    }
    CreditCard.discriminator = "classType";
    CreditCard.attributeTypeMap = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expiryMonth",
            "baseName": "expiry_month",
            "type": "number"
        },
        {
            "name": "expiryYear",
            "baseName": "expiry_year",
            "type": "number"
        },
        {
            "name": "cvc",
            "baseName": "cvc",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        }
    ];
    return CreditCard;
})();
exports.CreditCard = CreditCard;
/**
* All dates before specified timestam.
*/
let DateBefore = /** @class */ (() => {
    class DateBefore {
        static getAttributeTypeMap() {
            return DateBefore.attributeTypeMap;
        }
    }
    DateBefore.discriminator = "classType";
    DateBefore.attributeTypeMap = [
        {
            "name": "dateBefore",
            "baseName": "date_before",
            "type": "number"
        }
    ];
    return DateBefore;
})();
exports.DateBefore = DateBefore;
/**
* Issues with message delivery
*/
let DeliveryIssue = /** @class */ (() => {
    class DeliveryIssue {
        static getAttributeTypeMap() {
            return DeliveryIssue.attributeTypeMap;
        }
    }
    DeliveryIssue.discriminator = "classType";
    DeliveryIssue.attributeTypeMap = [
        {
            "name": "messageId",
            "baseName": "message_id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "clientComments",
            "baseName": "client_comments",
            "type": "string"
        },
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        }
    ];
    return DeliveryIssue;
})();
exports.DeliveryIssue = DeliveryIssue;
/**
* Model for a Delivery Receipt
*/
let DeliveryReceiptRule = /** @class */ (() => {
    class DeliveryReceiptRule {
        static getAttributeTypeMap() {
            return DeliveryReceiptRule.attributeTypeMap;
        }
    }
    DeliveryReceiptRule.discriminator = "classType";
    DeliveryReceiptRule.attributeTypeMap = [
        {
            "name": "ruleName",
            "baseName": "rule_name",
            "type": "string"
        },
        {
            "name": "matchType",
            "baseName": "match_type",
            "type": "number"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "actionAddress",
            "baseName": "action_address",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "number"
        }
    ];
    return DeliveryReceiptRule;
})();
exports.DeliveryReceiptRule = DeliveryReceiptRule;
/**
* Send Email
*/
let Email = /** @class */ (() => {
    class Email {
        static getAttributeTypeMap() {
            return Email.attributeTypeMap;
        }
    }
    Email.discriminator = "classType";
    Email.attributeTypeMap = [
        {
            "name": "to",
            "baseName": "to",
            "type": "Array<EmailRecipient>"
        },
        {
            "name": "cc",
            "baseName": "cc",
            "type": "Array<EmailRecipient>"
        },
        {
            "name": "bcc",
            "baseName": "bcc",
            "type": "Array<EmailRecipient>"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "EmailFrom"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<Attachment>"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        }
    ];
    return Email;
})();
exports.Email = Email;
let EmailAddress = /** @class */ (() => {
    class EmailAddress {
        static getAttributeTypeMap() {
            return EmailAddress.attributeTypeMap;
        }
    }
    EmailAddress.discriminator = undefined;
    EmailAddress.attributeTypeMap = [
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        }
    ];
    return EmailAddress;
})();
exports.EmailAddress = EmailAddress;
/**
* Campaign Model for Email
*/
let EmailCampaign = /** @class */ (() => {
    class EmailCampaign {
        static getAttributeTypeMap() {
            return EmailCampaign.attributeTypeMap;
        }
    }
    EmailCampaign.discriminator = "classType";
    EmailCampaign.attributeTypeMap = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "fromEmailAddressId",
            "baseName": "from_email_address_id",
            "type": "number"
        },
        {
            "name": "fromName",
            "baseName": "from_name",
            "type": "string"
        },
        {
            "name": "templateId",
            "baseName": "template_id",
            "type": "number"
        },
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        }
    ];
    return EmailCampaign;
})();
exports.EmailCampaign = EmailCampaign;
/**
* From Email object.
*/
let EmailFrom = /** @class */ (() => {
    class EmailFrom {
        static getAttributeTypeMap() {
            return EmailFrom.attributeTypeMap;
        }
    }
    EmailFrom.discriminator = undefined;
    EmailFrom.attributeTypeMap = [
        {
            "name": "emailAddressId",
            "baseName": "email_address_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }
    ];
    return EmailFrom;
})();
exports.EmailFrom = EmailFrom;
/**
* Recipient of an email, either To, Cc, or Bcc.
*/
let EmailRecipient = /** @class */ (() => {
    class EmailRecipient {
        static getAttributeTypeMap() {
            return EmailRecipient.attributeTypeMap;
        }
    }
    EmailRecipient.discriminator = "classType";
    EmailRecipient.attributeTypeMap = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }
    ];
    return EmailRecipient;
})();
exports.EmailRecipient = EmailRecipient;
/**
* Email-to-SMS Allowed Address
*/
let EmailSMSAddress = /** @class */ (() => {
    class EmailSMSAddress {
        static getAttributeTypeMap() {
            return EmailSMSAddress.attributeTypeMap;
        }
    }
    EmailSMSAddress.discriminator = "classType";
    EmailSMSAddress.attributeTypeMap = [
        {
            "name": "emailAddress",
            "baseName": "email_address",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "subaccountId",
            "baseName": "subaccount_id",
            "type": "string"
        }
    ];
    return EmailSMSAddress;
})();
exports.EmailSMSAddress = EmailSMSAddress;
/**
* Model for Email Templates
*/
let EmailTemplateNew = /** @class */ (() => {
    class EmailTemplateNew {
        static getAttributeTypeMap() {
            return EmailTemplateNew.attributeTypeMap;
        }
    }
    EmailTemplateNew.discriminator = "classType";
    EmailTemplateNew.attributeTypeMap = [
        {
            "name": "templateName",
            "baseName": "template_name",
            "type": "string"
        },
        {
            "name": "templateIdMaster",
            "baseName": "template_id_master",
            "type": "number"
        }
    ];
    return EmailTemplateNew;
})();
exports.EmailTemplateNew = EmailTemplateNew;
/**
* Model for Email Templates
*/
let EmailTemplateUpdate = /** @class */ (() => {
    class EmailTemplateUpdate {
        static getAttributeTypeMap() {
            return EmailTemplateUpdate.attributeTypeMap;
        }
    }
    EmailTemplateUpdate.discriminator = "classType";
    EmailTemplateUpdate.attributeTypeMap = [
        {
            "name": "templateName",
            "baseName": "template_name",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }
    ];
    return EmailTemplateUpdate;
})();
exports.EmailTemplateUpdate = EmailTemplateUpdate;
/**
* Base model for Fax Messages
*/
let FaxMessage = /** @class */ (() => {
    class FaxMessage {
        static getAttributeTypeMap() {
            return FaxMessage.attributeTypeMap;
        }
    }
    FaxMessage.discriminator = "classType";
    FaxMessage.attributeTypeMap = [
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        },
        {
            "name": "customString",
            "baseName": "custom_string",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "fromEmail",
            "baseName": "from_email",
            "type": "string"
        }
    ];
    return FaxMessage;
})();
exports.FaxMessage = FaxMessage;
/**
* Array of FaxMessage items
*/
let FaxMessageCollection = /** @class */ (() => {
    class FaxMessageCollection {
        static getAttributeTypeMap() {
            return FaxMessageCollection.attributeTypeMap;
        }
    }
    FaxMessageCollection.discriminator = "classType";
    FaxMessageCollection.attributeTypeMap = [
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<FaxMessage>"
        },
        {
            "name": "fileUrl",
            "baseName": "file_url",
            "type": "string"
        }
    ];
    return FaxMessageCollection;
})();
exports.FaxMessageCollection = FaxMessageCollection;
/**
* Contains all details for the main contact.
*/
let Fields = /** @class */ (() => {
    class Fields {
        static getAttributeTypeMap() {
            return Fields.attributeTypeMap;
        }
    }
    Fields.discriminator = "classType";
    Fields.attributeTypeMap = [
        {
            "name": "fields",
            "baseName": "fields",
            "type": "FieldsFields"
        }
    ];
    return Fields;
})();
exports.Fields = Fields;
/**
* From Email object.
*/
let FieldsFields = /** @class */ (() => {
    class FieldsFields {
        static getAttributeTypeMap() {
            return FieldsFields.attributeTypeMap;
        }
    }
    FieldsFields.discriminator = undefined;
    FieldsFields.attributeTypeMap = [
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "custom1",
            "baseName": "custom_1",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "faxNumber",
            "baseName": "fax_number",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "addressLine1",
            "baseName": "address_line_1",
            "type": "string"
        },
        {
            "name": "addressLine2",
            "baseName": "address_line_2",
            "type": "string"
        },
        {
            "name": "addressCity",
            "baseName": "address_city",
            "type": "string"
        },
        {
            "name": "addressState",
            "baseName": "address_state",
            "type": "string"
        },
        {
            "name": "addressPostalCode",
            "baseName": "address_postal_code",
            "type": "string"
        },
        {
            "name": "addressCountry",
            "baseName": "address_country",
            "type": "string"
        },
        {
            "name": "organizationName",
            "baseName": "organization_name",
            "type": "string"
        },
        {
            "name": "custom2",
            "baseName": "custom_2",
            "type": "string"
        },
        {
            "name": "custom3",
            "baseName": "custom_3",
            "type": "string"
        },
        {
            "name": "custom4",
            "baseName": "custom_4",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        }
    ];
    return FieldsFields;
})();
exports.FieldsFields = FieldsFields;
let ForgotPassword = /** @class */ (() => {
    class ForgotPassword {
        static getAttributeTypeMap() {
            return ForgotPassword.attributeTypeMap;
        }
    }
    ForgotPassword.discriminator = undefined;
    ForgotPassword.attributeTypeMap = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }
    ];
    return ForgotPassword;
})();
exports.ForgotPassword = ForgotPassword;
let ForgotUsername = /** @class */ (() => {
    class ForgotUsername {
        static getAttributeTypeMap() {
            return ForgotUsername.attributeTypeMap;
        }
    }
    ForgotUsername.discriminator = undefined;
    ForgotUsername.attributeTypeMap = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        }
    ];
    return ForgotUsername;
})();
exports.ForgotUsername = ForgotUsername;
/**
* Model for Inbound FAX Rules
*/
let InboundFaxRule = /** @class */ (() => {
    class InboundFaxRule {
        static getAttributeTypeMap() {
            return InboundFaxRule.attributeTypeMap;
        }
    }
    InboundFaxRule.discriminator = "classType";
    InboundFaxRule.attributeTypeMap = [
        {
            "name": "dedicatedNumber",
            "baseName": "dedicated_number",
            "type": "string"
        },
        {
            "name": "ruleName",
            "baseName": "rule_name",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "actionAddress",
            "baseName": "action_address",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "number"
        }
    ];
    return InboundFaxRule;
})();
exports.InboundFaxRule = InboundFaxRule;
/**
* Model for Inbound SMS Rules
*/
let InboundSMSRule = /** @class */ (() => {
    class InboundSMSRule {
        static getAttributeTypeMap() {
            return InboundSMSRule.attributeTypeMap;
        }
    }
    InboundSMSRule.discriminator = "classType";
    InboundSMSRule.attributeTypeMap = [
        {
            "name": "dedicatedNumber",
            "baseName": "dedicated_number",
            "type": "string"
        },
        {
            "name": "ruleName",
            "baseName": "rule_name",
            "type": "string"
        },
        {
            "name": "messageSearchType",
            "baseName": "message_search_type",
            "type": "number"
        },
        {
            "name": "messageSearchTerm",
            "baseName": "message_search_term",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "actionAddress",
            "baseName": "action_address",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "number"
        }
    ];
    return InboundSMSRule;
})();
exports.InboundSMSRule = InboundSMSRule;
/**
* Campaign Model for MMS
*/
let MmsCampaign = /** @class */ (() => {
    class MmsCampaign {
        static getAttributeTypeMap() {
            return MmsCampaign.attributeTypeMap;
        }
    }
    MmsCampaign.discriminator = "classType";
    MmsCampaign.attributeTypeMap = [
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "mediaFile",
            "baseName": "media_file",
            "type": "string"
        }
    ];
    return MmsCampaign;
})();
exports.MmsCampaign = MmsCampaign;
/**
* Single MMS message model
*/
let MmsMessage = /** @class */ (() => {
    class MmsMessage {
        static getAttributeTypeMap() {
            return MmsMessage.attributeTypeMap;
        }
    }
    MmsMessage.discriminator = "classType";
    MmsMessage.attributeTypeMap = [
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        },
        {
            "name": "customString",
            "baseName": "custom_string",
            "type": "string"
        },
        {
            "name": "fromEmail",
            "baseName": "from_email",
            "type": "string"
        }
    ];
    return MmsMessage;
})();
exports.MmsMessage = MmsMessage;
/**
* Array of MmsMessage items
*/
let MmsMessageCollection = /** @class */ (() => {
    class MmsMessageCollection {
        static getAttributeTypeMap() {
            return MmsMessageCollection.attributeTypeMap;
        }
    }
    MmsMessageCollection.discriminator = "classType";
    MmsMessageCollection.attributeTypeMap = [
        {
            "name": "mediaFile",
            "baseName": "media_file",
            "type": "string"
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<MmsMessage>"
        }
    ];
    return MmsMessageCollection;
})();
exports.MmsMessageCollection = MmsMessageCollection;
/**
* PostLetter model
*/
let PostLetter = /** @class */ (() => {
    class PostLetter {
        static getAttributeTypeMap() {
            return PostLetter.attributeTypeMap;
        }
    }
    PostLetter.discriminator = "classType";
    PostLetter.attributeTypeMap = [
        {
            "name": "fileUrl",
            "baseName": "file_url",
            "type": "string"
        },
        {
            "name": "priorityPost",
            "baseName": "priority_post",
            "type": "number"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<PostRecipient>"
        },
        {
            "name": "templateUsed",
            "baseName": "template_used",
            "type": "number"
        },
        {
            "name": "duplex",
            "baseName": "duplex",
            "type": "number"
        },
        {
            "name": "colour",
            "baseName": "colour",
            "type": "number"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }
    ];
    return PostLetter;
})();
exports.PostLetter = PostLetter;
/**
* PostPostcard model
*/
let PostPostcard = /** @class */ (() => {
    class PostPostcard {
        static getAttributeTypeMap() {
            return PostPostcard.attributeTypeMap;
        }
    }
    PostPostcard.discriminator = "classType";
    PostPostcard.attributeTypeMap = [
        {
            "name": "fileUrls",
            "baseName": "file_urls",
            "type": "Array<string>"
        },
        {
            "name": "recipients",
            "baseName": "recipients",
            "type": "Array<PostRecipient>"
        }
    ];
    return PostPostcard;
})();
exports.PostPostcard = PostPostcard;
/**
* PostRecipient model
*/
let PostRecipient = /** @class */ (() => {
    class PostRecipient {
        static getAttributeTypeMap() {
            return PostRecipient.attributeTypeMap;
        }
    }
    PostRecipient.discriminator = "classType";
    PostRecipient.attributeTypeMap = [
        {
            "name": "addressName",
            "baseName": "address_name",
            "type": "string"
        },
        {
            "name": "addressLine1",
            "baseName": "address_line_1",
            "type": "string"
        },
        {
            "name": "addressLine2",
            "baseName": "address_line_2",
            "type": "string"
        },
        {
            "name": "addressCity",
            "baseName": "address_city",
            "type": "string"
        },
        {
            "name": "addressState",
            "baseName": "address_state",
            "type": "string"
        },
        {
            "name": "addressPostalCode",
            "baseName": "address_postal_code",
            "type": "string"
        },
        {
            "name": "addressCountry",
            "baseName": "address_country",
            "type": "string"
        },
        {
            "name": "returnAddressId",
            "baseName": "return_address_id",
            "type": "number"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        }
    ];
    return PostRecipient;
})();
exports.PostRecipient = PostRecipient;
/**
* ResellerAccount model
*/
let ResellerAccount = /** @class */ (() => {
    class ResellerAccount {
        static getAttributeTypeMap() {
            return ResellerAccount.attributeTypeMap;
        }
    }
    ResellerAccount.discriminator = "classType";
    ResellerAccount.attributeTypeMap = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "userEmail",
            "baseName": "user_email",
            "type": "string"
        },
        {
            "name": "userPhone",
            "baseName": "user_phone",
            "type": "string"
        },
        {
            "name": "userFirstName",
            "baseName": "user_first_name",
            "type": "string"
        },
        {
            "name": "userLastName",
            "baseName": "user_last_name",
            "type": "string"
        },
        {
            "name": "accountName",
            "baseName": "account_name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }
    ];
    return ResellerAccount;
})();
exports.ResellerAccount = ResellerAccount;
/**
* ResellerAccountTransferCredit model
*/
let ResellerAccountTransferCredit = /** @class */ (() => {
    class ResellerAccountTransferCredit {
        static getAttributeTypeMap() {
            return ResellerAccountTransferCredit.attributeTypeMap;
        }
    }
    ResellerAccountTransferCredit.discriminator = "classType";
    ResellerAccountTransferCredit.attributeTypeMap = [
        {
            "name": "clientUserId",
            "baseName": "client_user_id",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }
    ];
    return ResellerAccountTransferCredit;
})();
exports.ResellerAccountTransferCredit = ResellerAccountTransferCredit;
/**
* Campaign Model for SMS
*/
let SmsCampaign = /** @class */ (() => {
    class SmsCampaign {
        static getAttributeTypeMap() {
            return SmsCampaign.attributeTypeMap;
        }
    }
    SmsCampaign.discriminator = "classType";
    SmsCampaign.attributeTypeMap = [
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        },
        {
            "name": "urlToShorten",
            "baseName": "url_to_shorten",
            "type": "string"
        }
    ];
    return SmsCampaign;
})();
exports.SmsCampaign = SmsCampaign;
/**
* SmsMessage model
*/
let SmsMessage = /** @class */ (() => {
    class SmsMessage {
        static getAttributeTypeMap() {
            return SmsMessage.attributeTypeMap;
        }
    }
    SmsMessage.discriminator = "classType";
    SmsMessage.attributeTypeMap = [
        {
            "name": "from",
            "baseName": "from",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        },
        {
            "name": "customString",
            "baseName": "custom_string",
            "type": "string"
        },
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "fromEmail",
            "baseName": "from_email",
            "type": "string"
        }
    ];
    return SmsMessage;
})();
exports.SmsMessage = SmsMessage;
/**
* Array of SmsMessage items
*/
let SmsMessageCollection = /** @class */ (() => {
    class SmsMessageCollection {
        static getAttributeTypeMap() {
            return SmsMessageCollection.attributeTypeMap;
        }
    }
    SmsMessageCollection.discriminator = "classType";
    SmsMessageCollection.attributeTypeMap = [
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<SmsMessage>"
        }
    ];
    return SmsMessageCollection;
})();
exports.SmsMessageCollection = SmsMessageCollection;
/**
* SmsTemplate model
*/
let SmsTemplate = /** @class */ (() => {
    class SmsTemplate {
        static getAttributeTypeMap() {
            return SmsTemplate.attributeTypeMap;
        }
    }
    SmsTemplate.discriminator = "classType";
    SmsTemplate.attributeTypeMap = [
        {
            "name": "templateName",
            "baseName": "template_name",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }
    ];
    return SmsTemplate;
})();
exports.SmsTemplate = SmsTemplate;
/**
* String to be stripped.
*/
let StrippedString = /** @class */ (() => {
    class StrippedString {
        static getAttributeTypeMap() {
            return StrippedString.attributeTypeMap;
        }
    }
    StrippedString.discriminator = "classType";
    StrippedString.attributeTypeMap = [
        {
            "name": "stripString",
            "baseName": "strip_string",
            "type": "string"
        }
    ];
    return StrippedString;
})();
exports.StrippedString = StrippedString;
/**
* Accounts that are maintained under a main account
*/
let Subaccount = /** @class */ (() => {
    class Subaccount {
        static getAttributeTypeMap() {
            return Subaccount.attributeTypeMap;
        }
    }
    Subaccount.discriminator = "classType";
    Subaccount.attributeTypeMap = [
        {
            "name": "apiUsername",
            "baseName": "api_username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phone_number",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "accessUsers",
            "baseName": "access_users",
            "type": "number"
        },
        {
            "name": "accessBilling",
            "baseName": "access_billing",
            "type": "number"
        },
        {
            "name": "accessReporting",
            "baseName": "access_reporting",
            "type": "number"
        },
        {
            "name": "accessContacts",
            "baseName": "access_contacts",
            "type": "number"
        },
        {
            "name": "accessSettings",
            "baseName": "access_settings",
            "type": "number"
        }
    ];
    return Subaccount;
})();
exports.Subaccount = Subaccount;
/**
* Your file to be uploaded.
*/
let UploadFile = /** @class */ (() => {
    class UploadFile {
        static getAttributeTypeMap() {
            return UploadFile.attributeTypeMap;
        }
    }
    UploadFile.discriminator = "classType";
    UploadFile.attributeTypeMap = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }
    ];
    return UploadFile;
})();
exports.UploadFile = UploadFile;
/**
* Your url.
*/
let Url = /** @class */ (() => {
    class Url {
        static getAttributeTypeMap() {
            return Url.attributeTypeMap;
        }
    }
    Url.discriminator = "classType";
    Url.attributeTypeMap = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }
    ];
    return Url;
})();
exports.Url = Url;
/**
* VoiceMessage fields: source, to, list_id, body, lang, voice, schedule, custom_string, country
*/
let VoiceMessage = /** @class */ (() => {
    class VoiceMessage {
        static getAttributeTypeMap() {
            return VoiceMessage.attributeTypeMap;
        }
    }
    VoiceMessage.discriminator = "classType";
    VoiceMessage.attributeTypeMap = [
        {
            "name": "to",
            "baseName": "to",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "voice",
            "baseName": "voice",
            "type": "string"
        },
        {
            "name": "customString",
            "baseName": "custom_string",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "listId",
            "baseName": "list_id",
            "type": "number"
        },
        {
            "name": "lang",
            "baseName": "lang",
            "type": "string"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "number"
        },
        {
            "name": "requireInput",
            "baseName": "require_input",
            "type": "number"
        },
        {
            "name": "machineDetection",
            "baseName": "machine_detection",
            "type": "number"
        }
    ];
    return VoiceMessage;
})();
exports.VoiceMessage = VoiceMessage;
/**
* Array of VoiceMessage items
*/
let VoiceMessageCollection = /** @class */ (() => {
    class VoiceMessageCollection {
        static getAttributeTypeMap() {
            return VoiceMessageCollection.attributeTypeMap;
        }
    }
    VoiceMessageCollection.discriminator = "classType";
    VoiceMessageCollection.attributeTypeMap = [
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<VoiceMessage>"
        }
    ];
    return VoiceMessageCollection;
})();
exports.VoiceMessageCollection = VoiceMessageCollection;
let enumsMap = {};
let typeMap = {
    "Account": Account,
    "AccountForgotPasswordVerify": AccountForgotPasswordVerify,
    "AccountVerify": AccountVerify,
    "Address": Address,
    "Attachment": Attachment,
    "Contact": Contact,
    "ContactList": ContactList,
    "ContactListImport": ContactListImport,
    "CreditCard": CreditCard,
    "DateBefore": DateBefore,
    "DeliveryIssue": DeliveryIssue,
    "DeliveryReceiptRule": DeliveryReceiptRule,
    "Email": Email,
    "EmailAddress": EmailAddress,
    "EmailCampaign": EmailCampaign,
    "EmailFrom": EmailFrom,
    "EmailRecipient": EmailRecipient,
    "EmailSMSAddress": EmailSMSAddress,
    "EmailTemplateNew": EmailTemplateNew,
    "EmailTemplateUpdate": EmailTemplateUpdate,
    "FaxMessage": FaxMessage,
    "FaxMessageCollection": FaxMessageCollection,
    "Fields": Fields,
    "FieldsFields": FieldsFields,
    "ForgotPassword": ForgotPassword,
    "ForgotUsername": ForgotUsername,
    "InboundFaxRule": InboundFaxRule,
    "InboundSMSRule": InboundSMSRule,
    "MmsCampaign": MmsCampaign,
    "MmsMessage": MmsMessage,
    "MmsMessageCollection": MmsMessageCollection,
    "PostLetter": PostLetter,
    "PostPostcard": PostPostcard,
    "PostRecipient": PostRecipient,
    "ResellerAccount": ResellerAccount,
    "ResellerAccountTransferCredit": ResellerAccountTransferCredit,
    "SmsCampaign": SmsCampaign,
    "SmsMessage": SmsMessage,
    "SmsMessageCollection": SmsMessageCollection,
    "SmsTemplate": SmsTemplate,
    "StrippedString": StrippedString,
    "Subaccount": Subaccount,
    "UploadFile": UploadFile,
    "Url": Url,
    "VoiceMessage": VoiceMessage,
    "VoiceMessageCollection": VoiceMessageCollection,
};
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var AccountApiApiKeys;
(function (AccountApiApiKeys) {
})(AccountApiApiKeys = exports.AccountApiApiKeys || (exports.AccountApiApiKeys = {}));
class AccountApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AccountApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get account details
     * @summary Get account information
     * @param {*} [options] Override http request options.
     */
    accountGet(options = {}) {
        const localVarPath = this.basePath + '/account';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create An Account
     * @summary Create a new account
     * @param account Account model
     * @param {*} [options] Override http request options.
     */
    accountPost(account, options = {}) {
        const localVarPath = this.basePath + '/account';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling accountPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(account, "Account")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get account useage by subaccount
     * @summary Get account useage by subaccount
     * @param year Year to filter by (yyyy)
     * @param month Month to filter by (mm)
     * @param {*} [options] Override http request options.
     */
    accountUseageBySubaccountGet(year, month, options = {}) {
        const localVarPath = this.basePath + '/account/usage/{year}/{month}/subaccount'
            .replace('{' + 'year' + '}', encodeURIComponent(String(year)))
            .replace('{' + 'month' + '}', encodeURIComponent(String(month)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'year' is not null or undefined
        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling accountUseageBySubaccountGet.');
        }
        // verify required parameter 'month' is not null or undefined
        if (month === null || month === undefined) {
            throw new Error('Required parameter month was null or undefined when calling accountUseageBySubaccountGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send account activation token
     * @summary Send account activation token
     * @param accountVerify Account details
     * @param {*} [options] Override http request options.
     */
    accountVerifySendPut(accountVerify, options = {}) {
        const localVarPath = this.basePath + '/account-verify/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'accountVerify' is not null or undefined
        if (accountVerify === null || accountVerify === undefined) {
            throw new Error('Required parameter accountVerify was null or undefined when calling accountVerifySendPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(accountVerify, "AccountVerify")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Verify new account
     * @summary Verify new account
     * @param activationToken
     * @param {*} [options] Override http request options.
     */
    accountVerifyVerifyByActivationTokenPut(activationToken, options = {}) {
        const localVarPath = this.basePath + '/account-verify/verify/{activation_token}'
            .replace('{' + 'activation_token' + '}', encodeURIComponent(String(activationToken)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'activationToken' is not null or undefined
        if (activationToken === null || activationToken === undefined) {
            throw new Error('Required parameter activationToken was null or undefined when calling accountVerifyVerifyByActivationTokenPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Forgot password
     * @summary Forgot password
     * @param forgotPassword
     * @param {*} [options] Override http request options.
     */
    forgotPasswordPut(forgotPassword, options = {}) {
        const localVarPath = this.basePath + '/forgot-password';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(forgotPassword, "ForgotPassword")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Verify forgot password
     * @summary Verify forgot password
     * @param verifyPassword verifyPassword data
     * @param {*} [options] Override http request options.
     */
    forgotPasswordVerifyPut(verifyPassword, options = {}) {
        const localVarPath = this.basePath + '/forgot-password/verify';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'verifyPassword' is not null or undefined
        if (verifyPassword === null || verifyPassword === undefined) {
            throw new Error('Required parameter verifyPassword was null or undefined when calling forgotPasswordVerifyPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(verifyPassword, "AccountForgotPasswordVerify")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Forgot username
     * @summary Forgot username
     * @param forgotUsername
     * @param {*} [options] Override http request options.
     */
    forgotUsernamePut(forgotUsername, options = {}) {
        const localVarPath = this.basePath + '/forgot-username';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(forgotUsername, "ForgotUsername")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AccountApi = AccountApi;
var AccountRechargeApiApiKeys;
(function (AccountRechargeApiApiKeys) {
})(AccountRechargeApiApiKeys = exports.AccountRechargeApiApiKeys || (exports.AccountRechargeApiApiKeys = {}));
class AccountRechargeApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[AccountRechargeApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get Credit Card info
     * @summary Get Credit Card info
     * @param {*} [options] Override http request options.
     */
    rechargeCreditCardGet(options = {}) {
        const localVarPath = this.basePath + '/recharge/credit-card';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update credit card info
     * @summary Update credit card info
     * @param creditCard CreditCard model
     * @param {*} [options] Override http request options.
     */
    rechargeCreditCardPut(creditCard, options = {}) {
        const localVarPath = this.basePath + '/recharge/credit-card';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling rechargeCreditCardPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(creditCard, "CreditCard")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of all packages
     * @summary Get list of all packages
     * @param country Country code
     * @param {*} [options] Override http request options.
     */
    rechargePackagesGet(country, options = {}) {
        const localVarPath = this.basePath + '/recharge/packages';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (country !== undefined) {
            localVarQueryParameters['country'] = ObjectSerializer.serialize(country, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Purchase a package
     * @summary Purchase a package
     * @param packageId ID of package to purchase
     * @param {*} [options] Override http request options.
     */
    rechargePurchaseByPackageIdPut(packageId, options = {}) {
        const localVarPath = this.basePath + '/recharge/purchase/{package_id}'
            .replace('{' + 'package_id' + '}', encodeURIComponent(String(packageId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'packageId' is not null or undefined
        if (packageId === null || packageId === undefined) {
            throw new Error('Required parameter packageId was null or undefined when calling rechargePurchaseByPackageIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific Transaction
     * @summary Get specific Transaction
     * @param transactionId ID of transaction to retrieve
     * @param {*} [options] Override http request options.
     */
    rechargeTransactionsByTransactionIdGet(transactionId, options = {}) {
        const localVarPath = this.basePath + '/recharge/transactions/{transaction_id}'
            .replace('{' + 'transaction_id' + '}', encodeURIComponent(String(transactionId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling rechargeTransactionsByTransactionIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all transactions
     * @summary Purchase a package
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    rechargeTransactionsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/recharge/transactions';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.AccountRechargeApi = AccountRechargeApi;
var ContactApiApiKeys;
(function (ContactApiApiKeys) {
})(ContactApiApiKeys = exports.ContactApiApiKeys || (exports.ContactApiApiKeys = {}));
class ContactApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ContactApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete a contact
     * @summary Delete a contact
     * @param listId List ID
     * @param contactId Contact ID
     * @param {*} [options] Override http request options.
     */
    listsContactsByListIdAndContactIdDelete(listId, contactId, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/contacts/{contact_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)))
            .replace('{' + 'contact_id' + '}', encodeURIComponent(String(contactId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsContactsByListIdAndContactIdDelete.');
        }
        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling listsContactsByListIdAndContactIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a specific contact
     * @summary Get a specific contact
     * @param listId Your contact list id you want to access.
     * @param contactId Your contact id you want to access.
     * @param {*} [options] Override http request options.
     */
    listsContactsByListIdAndContactIdGet(listId, contactId, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/contacts/{contact_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)))
            .replace('{' + 'contact_id' + '}', encodeURIComponent(String(contactId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsContactsByListIdAndContactIdGet.');
        }
        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling listsContactsByListIdAndContactIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific contact
     * @summary Update specific contact
     * @param listId Contact list id
     * @param contactId Contact ID
     * @param contact Contact model
     * @param {*} [options] Override http request options.
     */
    listsContactsByListIdAndContactIdPut(listId, contactId, contact, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/contacts/{contact_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)))
            .replace('{' + 'contact_id' + '}', encodeURIComponent(String(contactId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsContactsByListIdAndContactIdPut.');
        }
        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling listsContactsByListIdAndContactIdPut.');
        }
        // verify required parameter 'contact' is not null or undefined
        if (contact === null || contact === undefined) {
            throw new Error('Required parameter contact was null or undefined when calling listsContactsByListIdAndContactIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contact, "Contact")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all contacts in a list
     * @summary Get all contacts in a list
     * @param listId Contact list ID
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    listsContactsByListIdGet(listId, page, limit, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/contacts'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsContactsByListIdGet.');
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create new contact
     * @summary Create new contact
     * @param contact Contact model
     * @param listId List id
     * @param {*} [options] Override http request options.
     */
    listsContactsByListIdPost(contact, listId, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/contacts'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'contact' is not null or undefined
        if (contact === null || contact === undefined) {
            throw new Error('Required parameter contact was null or undefined when calling listsContactsByListIdPost.');
        }
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsContactsByListIdPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contact, "Contact")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove all opted out contacts
     * @summary Remove all opted out contacts
     * @param listId Your list id
     * @param optOutListId Your opt out list id
     * @param {*} [options] Override http request options.
     */
    listsRemoveOptedOutContactsByListIdAndOptOutListIdPut(listId, optOutListId, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/remove-opted-out-contacts/{opt_out_list_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)))
            .replace('{' + 'opt_out_list_id' + '}', encodeURIComponent(String(optOutListId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsRemoveOptedOutContactsByListIdAndOptOutListIdPut.');
        }
        // verify required parameter 'optOutListId' is not null or undefined
        if (optOutListId === null || optOutListId === undefined) {
            throw new Error('Required parameter optOutListId was null or undefined when calling listsRemoveOptedOutContactsByListIdAndOptOutListIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Transfer contact to another list
     * @summary Transfer contact to another list
     * @param fromListId List ID for list that contains contact.
     * @param contactId Contact ID
     * @param toListId List ID for list you want to transfer contact to.
     * @param {*} [options] Override http request options.
     */
    listsTransferContactPut(fromListId, contactId, toListId, options = {}) {
        const localVarPath = this.basePath + '/lists/{from_list_id}/contacts/{contact_id}/transfer/{to_list_id}'
            .replace('{' + 'from_list_id' + '}', encodeURIComponent(String(fromListId)))
            .replace('{' + 'contact_id' + '}', encodeURIComponent(String(contactId)))
            .replace('{' + 'to_list_id' + '}', encodeURIComponent(String(toListId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'fromListId' is not null or undefined
        if (fromListId === null || fromListId === undefined) {
            throw new Error('Required parameter fromListId was null or undefined when calling listsTransferContactPut.');
        }
        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling listsTransferContactPut.');
        }
        // verify required parameter 'toListId' is not null or undefined
        if (toListId === null || toListId === undefined) {
            throw new Error('Required parameter toListId was null or undefined when calling listsTransferContactPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ContactApi = ContactApi;
var ContactListApiApiKeys;
(function (ContactListApiApiKeys) {
})(ContactListApiApiKeys = exports.ContactListApiApiKeys || (exports.ContactListApiApiKeys = {}));
class ContactListApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ContactListApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete a specific contact list
     * @summary ListsByListIdDelete
     * @param listId List ID
     * @param {*} [options] Override http request options.
     */
    listsByListIdDelete(listId, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsByListIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific contact list
     * @summary Get specific contact list
     * @param listId List ID
     * @param {*} [options] Override http request options.
     */
    listsByListIdGet(listId, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsByListIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update specific contact list
     * @summary Update specific contact list
     * @param listId Your list id
     * @param contactList Contact list model
     * @param {*} [options] Override http request options.
     */
    listsByListIdPut(listId, contactList, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsByListIdPut.');
        }
        // verify required parameter 'contactList' is not null or undefined
        if (contactList === null || contactList === undefined) {
            throw new Error('Required parameter contactList was null or undefined when calling listsByListIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactList, "ContactList")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all contact lists
     * @summary Get all contact lists
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    listsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/lists';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Import contacts to list
     * @summary Import contacts to list
     * @param listId Your contact list id you want to access.
     * @param file ContactListImport model
     * @param {*} [options] Override http request options.
     */
    listsImportByListIdPost(listId, file, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/import'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsImportByListIdPost.');
        }
        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling listsImportByListIdPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(file, "ContactListImport")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create new contact list
     * @summary Create new contact list
     * @param contactList Contact list model
     * @param {*} [options] Override http request options.
     */
    listsPost(contactList, options = {}) {
        const localVarPath = this.basePath + '/lists';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'contactList' is not null or undefined
        if (contactList === null || contactList === undefined) {
            throw new Error('Required parameter contactList was null or undefined when calling listsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(contactList, "ContactList")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove duplicate contacts
     * @summary Remove duplicate contacts
     * @param listId Your list id
     * @param fields Fields model
     * @param {*} [options] Override http request options.
     */
    listsRemoveDuplicatesByListIdPut(listId, fields, options = {}) {
        const localVarPath = this.basePath + '/lists/{list_id}/remove-duplicates'
            .replace('{' + 'list_id' + '}', encodeURIComponent(String(listId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'listId' is not null or undefined
        if (listId === null || listId === undefined) {
            throw new Error('Required parameter listId was null or undefined when calling listsRemoveDuplicatesByListIdPut.');
        }
        // verify required parameter 'fields' is not null or undefined
        if (fields === null || fields === undefined) {
            throw new Error('Required parameter fields was null or undefined when calling listsRemoveDuplicatesByListIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fields, "Fields")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ContactListApi = ContactListApi;
var CountriesApiApiKeys;
(function (CountriesApiApiKeys) {
})(CountriesApiApiKeys = exports.CountriesApiApiKeys || (exports.CountriesApiApiKeys = {}));
class CountriesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[CountriesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get all countries
     * @summary Get all country codes
     * @param {*} [options] Override http request options.
     */
    countriesGet(options = {}) {
        const localVarPath = this.basePath + '/countries';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.CountriesApi = CountriesApi;
var DeliveryIssuesApiApiKeys;
(function (DeliveryIssuesApiApiKeys) {
})(DeliveryIssuesApiApiKeys = exports.DeliveryIssuesApiApiKeys || (exports.DeliveryIssuesApiApiKeys = {}));
class DeliveryIssuesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DeliveryIssuesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get all delivery issues
     * @summary Get all delivery issues
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    deliveryIssuesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/delivery-issues';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create delivery Issue
     * @summary Create delivery Issue
     * @param deliveryIssue DeliveryIssue model
     * @param {*} [options] Override http request options.
     */
    deliveryIssuesPost(deliveryIssue, options = {}) {
        const localVarPath = this.basePath + '/delivery-issues';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryIssue' is not null or undefined
        if (deliveryIssue === null || deliveryIssue === undefined) {
            throw new Error('Required parameter deliveryIssue was null or undefined when calling deliveryIssuesPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryIssue, "DeliveryIssue")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DeliveryIssuesApi = DeliveryIssuesApi;
var DetectAddressApiApiKeys;
(function (DetectAddressApiApiKeys) {
})(DetectAddressApiApiKeys = exports.DetectAddressApiApiKeys || (exports.DetectAddressApiApiKeys = {}));
class DetectAddressApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DetectAddressApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Detects address in uploaded file.
     * @summary Detects address in uploaded file.
     * @param uploadFile Your file to be uploaded
     * @param {*} [options] Override http request options.
     */
    detectAddressPost(uploadFile, options = {}) {
        const localVarPath = this.basePath + '/post/letters/detect-address';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'uploadFile' is not null or undefined
        if (uploadFile === null || uploadFile === undefined) {
            throw new Error('Required parameter uploadFile was null or undefined when calling detectAddressPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uploadFile, "UploadFile")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DetectAddressApi = DetectAddressApi;
var EmailDeliveryReceiptRulesApiApiKeys;
(function (EmailDeliveryReceiptRulesApiApiKeys) {
})(EmailDeliveryReceiptRulesApiApiKeys = exports.EmailDeliveryReceiptRulesApiApiKeys || (exports.EmailDeliveryReceiptRulesApiApiKeys = {}));
class EmailDeliveryReceiptRulesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[EmailDeliveryReceiptRulesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete email delivery receipt automation
     * @summary Delete email delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    emailDeliveryReceiptAutomationDelete(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/email/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling emailDeliveryReceiptAutomationDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific email delivery receipt automation
     * @summary Get specific email delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    emailDeliveryReceiptAutomationGet(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/email/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling emailDeliveryReceiptAutomationGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create email delivery receipt automations
     * @summary Create email delivery receipt automations
     * @param deliveryReceiptRule Email delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    emailDeliveryReceiptAutomationPost(deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/email/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling emailDeliveryReceiptAutomationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email delivery receipt automation
     * @summary Update email delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param deliveryReceiptRule Delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    emailDeliveryReceiptAutomationPut(receiptRuleId, deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/email/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling emailDeliveryReceiptAutomationPut.');
        }
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling emailDeliveryReceiptAutomationPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all email delivery receipt automations
     * @summary Get all email delivery receipt automations
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    emailDeliveryReceiptAutomationsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/automations/email/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.EmailDeliveryReceiptRulesApi = EmailDeliveryReceiptRulesApi;
var EmailMarketingApiApiKeys;
(function (EmailMarketingApiApiKeys) {
})(EmailMarketingApiApiKeys = exports.EmailMarketingApiApiKeys || (exports.EmailMarketingApiApiKeys = {}));
class EmailMarketingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[EmailMarketingApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get all email addresses
     * @summary Get all email addresses
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    allowedEmailAddressGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/email/addresses';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create allowed Email Address
     * @summary Create allowed Email Address
     * @param emailAddress
     * @param {*} [options] Override http request options.
     */
    allowedEmailAddressPost(emailAddress, options = {}) {
        const localVarPath = this.basePath + '/email/addresses';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailAddress, "EmailAddress")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel email campaign
     * @summary Cancel email campaign
     * @param emailCampaignId Allowed email campaign id
     * @param {*} [options] Override http request options.
     */
    cancelEmailCampaignPut(emailCampaignId, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/{email_campaign_id}/cancel'
            .replace('{' + 'email_campaign_id' + '}', encodeURIComponent(String(emailCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaignId' is not null or undefined
        if (emailCampaignId === null || emailCampaignId === undefined) {
            throw new Error('Required parameter emailCampaignId was null or undefined when calling cancelEmailCampaignPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific email campaign
     * @summary Get specific email campaign
     * @param emailCampaignId Allowed email campaign id
     * @param {*} [options] Override http request options.
     */
    emailCampaignGet(emailCampaignId, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/{email_campaign_id}'
            .replace('{' + 'email_campaign_id' + '}', encodeURIComponent(String(emailCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaignId' is not null or undefined
        if (emailCampaignId === null || emailCampaignId === undefined) {
            throw new Error('Required parameter emailCampaignId was null or undefined when calling emailCampaignGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export specific email campaign history
     * @summary Export specific email campaign history
     * @param emailCampaignId Allowed email campaign id
     * @param dateFrom Start date
     * @param dateTo End date
     * @param {*} [options] Override http request options.
     */
    emailCampaignHistoryExportGet(emailCampaignId, dateFrom, dateTo, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/{email_campaign_id}/history/export'
            .replace('{' + 'email_campaign_id' + '}', encodeURIComponent(String(emailCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaignId' is not null or undefined
        if (emailCampaignId === null || emailCampaignId === undefined) {
            throw new Error('Required parameter emailCampaignId was null or undefined when calling emailCampaignHistoryExportGet.');
        }
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific email campaign history
     * @summary Get specific email campaign history
     * @param emailCampaignId Allowed email campaign id
     * @param dateFrom Start date
     * @param dateTo End date
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    emailCampaignHistoryGet(emailCampaignId, dateFrom, dateTo, page, limit, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/{email_campaign_id}/history'
            .replace('{' + 'email_campaign_id' + '}', encodeURIComponent(String(emailCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaignId' is not null or undefined
        if (emailCampaignId === null || emailCampaignId === undefined) {
            throw new Error('Required parameter emailCampaignId was null or undefined when calling emailCampaignHistoryGet.');
        }
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send email campaign
     * @summary Send email campaign
     * @param emailCampaign Email model
     * @param {*} [options] Override http request options.
     */
    emailCampaignPost(emailCampaign, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling emailCampaignPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "EmailCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate email campaign price
     * @summary Calculate email campaign price
     * @param emailCampaign Email model
     * @param {*} [options] Override http request options.
     */
    emailCampaignPricePost(emailCampaign, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling emailCampaignPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "EmailCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit email campaign
     * @summary Edit email campaign
     * @param emailCampaignId Allowed email campaign id
     * @param emailCampaign Email model
     * @param {*} [options] Override http request options.
     */
    emailCampaignPut(emailCampaignId, emailCampaign, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns/{email_campaign_id}'
            .replace('{' + 'email_campaign_id' + '}', encodeURIComponent(String(emailCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailCampaignId' is not null or undefined
        if (emailCampaignId === null || emailCampaignId === undefined) {
            throw new Error('Required parameter emailCampaignId was null or undefined when calling emailCampaignPut.');
        }
        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling emailCampaignPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "EmailCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all email campaigns
     * @summary Get all email campaigns
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    emailCampaignsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/email-campaigns';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send verification token
     * @summary Send verification token
     * @param emailAddressId Allowed email address id
     * @param {*} [options] Override http request options.
     */
    sendVerificationTokenGet(emailAddressId, options = {}) {
        const localVarPath = this.basePath + '/email/address-verify/{email_address_id}/send'
            .replace('{' + 'email_address_id' + '}', encodeURIComponent(String(emailAddressId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailAddressId' is not null or undefined
        if (emailAddressId === null || emailAddressId === undefined) {
            throw new Error('Required parameter emailAddressId was null or undefined when calling sendVerificationTokenGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete specific email address
     * @summary Delete specific email address
     * @param emailAddressId Allowed email address id
     * @param {*} [options] Override http request options.
     */
    specificAllowedEmailAddressDelete(emailAddressId, options = {}) {
        const localVarPath = this.basePath + '/email/addresses/{email_address_id}'
            .replace('{' + 'email_address_id' + '}', encodeURIComponent(String(emailAddressId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailAddressId' is not null or undefined
        if (emailAddressId === null || emailAddressId === undefined) {
            throw new Error('Required parameter emailAddressId was null or undefined when calling specificAllowedEmailAddressDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific email address
     * @summary Get specific email address
     * @param emailAddressId Allowed email address id
     * @param {*} [options] Override http request options.
     */
    specificAllowedEmailAddressGet(emailAddressId, options = {}) {
        const localVarPath = this.basePath + '/email/addresses/{email_address_id}'
            .replace('{' + 'email_address_id' + '}', encodeURIComponent(String(emailAddressId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailAddressId' is not null or undefined
        if (emailAddressId === null || emailAddressId === undefined) {
            throw new Error('Required parameter emailAddressId was null or undefined when calling specificAllowedEmailAddressGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Verify email address using verification token
     * @summary Verify email address using verification token
     * @param emailAddressId Allowed email address id
     * @param activationToken Your activation token.
     * @param {*} [options] Override http request options.
     */
    verifyAllowedEmailAddressGet(emailAddressId, activationToken, options = {}) {
        const localVarPath = this.basePath + '/email/address-verify/{email_address_id}/verify/{activation_token}'
            .replace('{' + 'email_address_id' + '}', encodeURIComponent(String(emailAddressId)))
            .replace('{' + 'activation_token' + '}', encodeURIComponent(String(activationToken)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailAddressId' is not null or undefined
        if (emailAddressId === null || emailAddressId === undefined) {
            throw new Error('Required parameter emailAddressId was null or undefined when calling verifyAllowedEmailAddressGet.');
        }
        // verify required parameter 'activationToken' is not null or undefined
        if (activationToken === null || activationToken === undefined) {
            throw new Error('Required parameter activationToken was null or undefined when calling verifyAllowedEmailAddressGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.EmailMarketingApi = EmailMarketingApi;
var EmailToSmsApiApiKeys;
(function (EmailToSmsApiApiKeys) {
})(EmailToSmsApiApiKeys = exports.EmailToSmsApiApiKeys || (exports.EmailToSmsApiApiKeys = {}));
class EmailToSmsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[EmailToSmsApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get list of email to sms allowed addresses
     * @summary Get list of email to sms allowed addresses
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create email to sms allowed address
     * @summary Create email to sms allowed address
     * @param emailSmsAddress EmailSMSAddress model
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsPost(emailSmsAddress, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailSmsAddress' is not null or undefined
        if (emailSmsAddress === null || emailSmsAddress === undefined) {
            throw new Error('Required parameter emailSmsAddress was null or undefined when calling smsEmailSmsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailSmsAddress, "EmailSMSAddress")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete email to sms stripped string rule
     * @summary Delete email to sms stripped string rule
     * @param ruleId Your rule id
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsStrippedStringDelete(ruleId, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms-stripped-strings/{rule_id}'
            .replace('{' + 'rule_id' + '}', encodeURIComponent(String(ruleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling smsEmailSmsStrippedStringDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email to sms stripped string rule
     * @summary Get email to sms stripped string rule
     * @param ruleId Your rule id
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsStrippedStringGet(ruleId, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms-stripped-strings/{rule_id}'
            .replace('{' + 'rule_id' + '}', encodeURIComponent(String(ruleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling smsEmailSmsStrippedStringGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create email to sms stripped string rules
     * @summary Create email to sms stripped string rule
     * @param strippedString StrippedString model
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsStrippedStringPost(strippedString, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms-stripped-strings';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'strippedString' is not null or undefined
        if (strippedString === null || strippedString === undefined) {
            throw new Error('Required parameter strippedString was null or undefined when calling smsEmailSmsStrippedStringPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(strippedString, "StrippedString")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email to sms stripped string rule
     * @summary Update email to sms stripped string rule
     * @param strippedString StrippedString model
     * @param ruleId Your rule id
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsStrippedStringPut(strippedString, ruleId, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms-stripped-strings/{rule_id}'
            .replace('{' + 'rule_id' + '}', encodeURIComponent(String(ruleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'strippedString' is not null or undefined
        if (strippedString === null || strippedString === undefined) {
            throw new Error('Required parameter strippedString was null or undefined when calling smsEmailSmsStrippedStringPut.');
        }
        // verify required parameter 'ruleId' is not null or undefined
        if (ruleId === null || ruleId === undefined) {
            throw new Error('Required parameter ruleId was null or undefined when calling smsEmailSmsStrippedStringPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(strippedString, "StrippedString")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of email to sms stripped string rules
     * @summary Get list of email to sms stripped string rules
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsEmailSmsStrippedStringsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms/email-sms-stripped-strings';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.EmailToSmsApi = EmailToSmsApi;
var FAXApiApiKeys;
(function (FAXApiApiKeys) {
})(FAXApiApiKeys = exports.FAXApiApiKeys || (exports.FAXApiApiKeys = {}));
class FAXApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[FAXApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get a list of Fax History.
     * @summary Get a list of Fax History.
     * @param dateFrom Customize result by setting from date (timestsamp) Example: 1457572619.
     * @param dateTo Customize result by setting to date (timestamp) Example: 1457573000.
     * @param q Custom query Example: status:Sent,status_code:201.
     * @param order Order result by Example: date_added:desc,list_id:desc.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    faxHistoryGet(dateFrom, dateTo, q, order, page, limit, options = {}) {
        const localVarPath = this.basePath + '/fax/history';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate Total Price for Fax Messages sent
     * @summary Calculate Total Price for Fax Messages sent
     * @param faxMessage FaxMessageCollection model
     * @param {*} [options] Override http request options.
     */
    faxPricePost(faxMessage, options = {}) {
        const localVarPath = this.basePath + '/fax/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'faxMessage' is not null or undefined
        if (faxMessage === null || faxMessage === undefined) {
            throw new Error('Required parameter faxMessage was null or undefined when calling faxPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(faxMessage, "FaxMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single fax receipt based on message id.
     * @summary Get a single fax receipt based on message id.
     * @param messageId ID of the message receipt to retrieve
     * @param {*} [options] Override http request options.
     */
    faxReceiptsByMessageIdGet(messageId, options = {}) {
        const localVarPath = this.basePath + '/fax/receipts/{message_id}'
            .replace('{' + 'message_id' + '}', encodeURIComponent(String(messageId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling faxReceiptsByMessageIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all delivery receipts
     * @summary Get all delivery receipts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    faxReceiptsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/fax/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a delivery receipt
     * @summary Add a delivery receipt
     * @param url Url model
     * @param {*} [options] Override http request options.
     */
    faxReceiptsPost(url, options = {}) {
        const localVarPath = this.basePath + '/fax/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling faxReceiptsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(url, "Url")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark delivery receipts as read
     * @summary Mark delivery receipts as read
     * @param dateBefore DateBefore model
     * @param {*} [options] Override http request options.
     */
    faxReceiptsReadPut(dateBefore, options = {}) {
        const localVarPath = this.basePath + '/fax/receipts-read';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dateBefore, "DateBefore")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a fax using supplied supported file-types.
     * @summary Send a fax using supplied supported file-types.
     * @param faxMessage FaxMessageCollection model
     * @param {*} [options] Override http request options.
     */
    faxSendPost(faxMessage, options = {}) {
        const localVarPath = this.basePath + '/fax/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'faxMessage' is not null or undefined
        if (faxMessage === null || faxMessage === undefined) {
            throw new Error('Required parameter faxMessage was null or undefined when calling faxSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(faxMessage, "FaxMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.FAXApi = FAXApi;
var FAXDeliveryReceiptRulesApiApiKeys;
(function (FAXDeliveryReceiptRulesApiApiKeys) {
})(FAXDeliveryReceiptRulesApiApiKeys = exports.FAXDeliveryReceiptRulesApiApiKeys || (exports.FAXDeliveryReceiptRulesApiApiKeys = {}));
class FAXDeliveryReceiptRulesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[FAXDeliveryReceiptRulesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete fax delivery receipt automation
     * @summary Delete fax delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    faxDeliveryReceiptAutomationDelete(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling faxDeliveryReceiptAutomationDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific fax delivery receipt automation
     * @summary Get specific fax delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    faxDeliveryReceiptAutomationGet(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling faxDeliveryReceiptAutomationGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create fax delivery receipt automations
     * @summary Create fax delivery receipt automations
     * @param deliveryReceiptRule fax delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    faxDeliveryReceiptAutomationPost(deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling faxDeliveryReceiptAutomationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update fax delivery receipt automation
     * @summary Update fax delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param deliveryReceiptRule Delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    faxDeliveryReceiptAutomationPut(receiptRuleId, deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling faxDeliveryReceiptAutomationPut.');
        }
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling faxDeliveryReceiptAutomationPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all fax delivery receipt automations
     * @summary Get all fax delivery receipt automations
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    faxDeliveryReceiptAutomationsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.FAXDeliveryReceiptRulesApi = FAXDeliveryReceiptRulesApi;
var InboundFAXRulesApiApiKeys;
(function (InboundFAXRulesApiApiKeys) {
})(InboundFAXRulesApiApiKeys = exports.InboundFAXRulesApiApiKeys || (exports.InboundFAXRulesApiApiKeys = {}));
class InboundFAXRulesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[InboundFAXRulesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete inbound fax automation
     * @summary Delete inbound fax automation
     * @param inboundRuleId Inbound rule id
     * @param {*} [options] Override http request options.
     */
    faxInboundAutomationDelete(inboundRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/inbound/{inbound_rule_id}'
            .replace('{' + 'inbound_rule_id' + '}', encodeURIComponent(String(inboundRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundRuleId' is not null or undefined
        if (inboundRuleId === null || inboundRuleId === undefined) {
            throw new Error('Required parameter inboundRuleId was null or undefined when calling faxInboundAutomationDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific inbound fax automation
     * @summary Get specific inbound fax automation
     * @param inboundRuleId Inbound rule id
     * @param {*} [options] Override http request options.
     */
    faxInboundAutomationGet(inboundRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/inbound/{inbound_rule_id}'
            .replace('{' + 'inbound_rule_id' + '}', encodeURIComponent(String(inboundRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundRuleId' is not null or undefined
        if (inboundRuleId === null || inboundRuleId === undefined) {
            throw new Error('Required parameter inboundRuleId was null or undefined when calling faxInboundAutomationGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create new inbound fax automation
     * @summary Create new inbound fax automation
     * @param inboundFaxRule Inbound fax rule model
     * @param {*} [options] Override http request options.
     */
    faxInboundAutomationPost(inboundFaxRule, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/inbound';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundFaxRule' is not null or undefined
        if (inboundFaxRule === null || inboundFaxRule === undefined) {
            throw new Error('Required parameter inboundFaxRule was null or undefined when calling faxInboundAutomationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inboundFaxRule, "InboundFaxRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update inbound fax automation
     * @summary Update inbound fax automation
     * @param inboundRuleId Inbound rule id
     * @param inboundFaxRule Inbound fax rule model
     * @param {*} [options] Override http request options.
     */
    faxInboundAutomationPut(inboundRuleId, inboundFaxRule, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/inbound/{inbound_rule_id}'
            .replace('{' + 'inbound_rule_id' + '}', encodeURIComponent(String(inboundRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundRuleId' is not null or undefined
        if (inboundRuleId === null || inboundRuleId === undefined) {
            throw new Error('Required parameter inboundRuleId was null or undefined when calling faxInboundAutomationPut.');
        }
        // verify required parameter 'inboundFaxRule' is not null or undefined
        if (inboundFaxRule === null || inboundFaxRule === undefined) {
            throw new Error('Required parameter inboundFaxRule was null or undefined when calling faxInboundAutomationPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inboundFaxRule, "InboundFaxRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all inbound fax automations
     * @summary Get all inbound fax automations
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    faxInboundAutomationsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/automations/fax/inbound';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.InboundFAXRulesApi = InboundFAXRulesApi;
var InboundSMSRulesApiApiKeys;
(function (InboundSMSRulesApiApiKeys) {
})(InboundSMSRulesApiApiKeys = exports.InboundSMSRulesApiApiKeys || (exports.InboundSMSRulesApiApiKeys = {}));
class InboundSMSRulesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[InboundSMSRulesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete inbound sms automation
     * @summary Delete inbound sms automation
     * @param inboundRuleId Inbound rule id
     * @param {*} [options] Override http request options.
     */
    smsInboundAutomationDelete(inboundRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/inbound/{inbound_rule_id}'
            .replace('{' + 'inbound_rule_id' + '}', encodeURIComponent(String(inboundRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundRuleId' is not null or undefined
        if (inboundRuleId === null || inboundRuleId === undefined) {
            throw new Error('Required parameter inboundRuleId was null or undefined when calling smsInboundAutomationDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific inbound sms automation
     * @summary Get specific inbound sms automation
     * @param inboundRuleId Inbound rule id
     * @param {*} [options] Override http request options.
     */
    smsInboundAutomationGet(inboundRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/inbound/{inbound_rule_id}'
            .replace('{' + 'inbound_rule_id' + '}', encodeURIComponent(String(inboundRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundRuleId' is not null or undefined
        if (inboundRuleId === null || inboundRuleId === undefined) {
            throw new Error('Required parameter inboundRuleId was null or undefined when calling smsInboundAutomationGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create new inbound sms automation
     * @summary Create new inbound sms automation
     * @param inboundSmsRule Inbound sms rule model
     * @param {*} [options] Override http request options.
     */
    smsInboundAutomationPost(inboundSmsRule, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/inbound';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundSmsRule' is not null or undefined
        if (inboundSmsRule === null || inboundSmsRule === undefined) {
            throw new Error('Required parameter inboundSmsRule was null or undefined when calling smsInboundAutomationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inboundSmsRule, "InboundSMSRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update inbound sms automation
     * @summary Update inbound sms automation
     * @param inboundRuleId Inbound rule id
     * @param inboundSmsRule Inbound sms rule model
     * @param {*} [options] Override http request options.
     */
    smsInboundAutomationPut(inboundRuleId, inboundSmsRule, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/inbound/{inbound_rule_id}'
            .replace('{' + 'inbound_rule_id' + '}', encodeURIComponent(String(inboundRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'inboundRuleId' is not null or undefined
        if (inboundRuleId === null || inboundRuleId === undefined) {
            throw new Error('Required parameter inboundRuleId was null or undefined when calling smsInboundAutomationPut.');
        }
        // verify required parameter 'inboundSmsRule' is not null or undefined
        if (inboundSmsRule === null || inboundSmsRule === undefined) {
            throw new Error('Required parameter inboundSmsRule was null or undefined when calling smsInboundAutomationPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inboundSmsRule, "InboundSMSRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all inbound sms automations
     * @summary Get all inbound sms automations
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsInboundAutomationsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/inbound';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.InboundSMSRulesApi = InboundSMSRulesApi;
var MMSApiApiKeys;
(function (MMSApiApiKeys) {
})(MMSApiApiKeys = exports.MMSApiApiKeys || (exports.MMSApiApiKeys = {}));
class MMSApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[MMSApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get Price for MMS sent
     * @summary Get Price for MMS sent
     * @param mmsMessages MmsMessageCollection model
     * @param {*} [options] Override http request options.
     */
    mmsPricePost(mmsMessages, options = {}) {
        const localVarPath = this.basePath + '/mms/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mmsMessages' is not null or undefined
        if (mmsMessages === null || mmsMessages === undefined) {
            throw new Error('Required parameter mmsMessages was null or undefined when calling mmsPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mmsMessages, "MmsMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all delivery receipts
     * @summary Get all delivery receipts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    mmsReceiptsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/mms/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark delivery receipts as read
     * @summary Mark delivery receipts as read
     * @param dateBefore DateBefore model
     * @param {*} [options] Override http request options.
     */
    mmsReceiptsReadPut(dateBefore, options = {}) {
        const localVarPath = this.basePath + '/mms/receipts-read';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dateBefore, "DateBefore")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send MMS
     * @summary Send MMS
     * @param mmsMessages MmsMessageCollection model
     * @param {*} [options] Override http request options.
     */
    mmsSendPost(mmsMessages, options = {}) {
        const localVarPath = this.basePath + '/mms/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mmsMessages' is not null or undefined
        if (mmsMessages === null || mmsMessages === undefined) {
            throw new Error('Required parameter mmsMessages was null or undefined when calling mmsSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mmsMessages, "MmsMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.MMSApi = MMSApi;
var MasterEmailTemplatesApiApiKeys;
(function (MasterEmailTemplatesApiApiKeys) {
})(MasterEmailTemplatesApiApiKeys = exports.MasterEmailTemplatesApiApiKeys || (exports.MasterEmailTemplatesApiApiKeys = {}));
class MasterEmailTemplatesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[MasterEmailTemplatesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get all master email template categories
     * @summary Get all master email template categories
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    masterEmailTemplateCategoriesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/email/master-templates-categories';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific master email template category
     * @summary Get specific master email template category
     * @param categoryId Email category id
     * @param {*} [options] Override http request options.
     */
    masterEmailTemplateCategoryGet(categoryId, options = {}) {
        const localVarPath = this.basePath + '/email/master-templates-categories/{category_id}'
            .replace('{' + 'category_id' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling masterEmailTemplateCategoryGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific master email template
     * @summary Get specific master email template
     * @param templateId Email template id
     * @param {*} [options] Override http request options.
     */
    masterEmailTemplateGet(templateId, options = {}) {
        const localVarPath = this.basePath + '/email/master-templates/{template_id}'
            .replace('{' + 'template_id' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling masterEmailTemplateGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all master email templates
     * @summary Get all master email templates
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    masterEmailTemplatesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/email/master-templates';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all master email templates in a category
     * @summary Get all master email templates in a category
     * @param categoryId Email category id
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    masterEmailTemplatesInCategoryGet(categoryId, page, limit, options = {}) {
        const localVarPath = this.basePath + '/email/master-templates-categories/{category_id}/master-templates'
            .replace('{' + 'category_id' + '}', encodeURIComponent(String(categoryId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'categoryId' is not null or undefined
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling masterEmailTemplatesInCategoryGet.');
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.MasterEmailTemplatesApi = MasterEmailTemplatesApi;
var MmsCampaignApiApiKeys;
(function (MmsCampaignApiApiKeys) {
})(MmsCampaignApiApiKeys = exports.MmsCampaignApiApiKeys || (exports.MmsCampaignApiApiKeys = {}));
class MmsCampaignApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[MmsCampaignApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get specific mms campaign
     * @summary Get specific mms campaign
     * @param mmsCampaignId ID of MMS campaign to retrieve
     * @param {*} [options] Override http request options.
     */
    mmsCampaignByMmsCampaignIdGet(mmsCampaignId, options = {}) {
        const localVarPath = this.basePath + '/mms-campaigns/{mms_campaign_id}'
            .replace('{' + 'mms_campaign_id' + '}', encodeURIComponent(String(mmsCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mmsCampaignId' is not null or undefined
        if (mmsCampaignId === null || mmsCampaignId === undefined) {
            throw new Error('Required parameter mmsCampaignId was null or undefined when calling mmsCampaignByMmsCampaignIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update mms campaign
     * @summary Update mms campaign
     * @param mmsCampaignId ID of MMS campaign to update
     * @param campaign MmsCampaign model
     * @param {*} [options] Override http request options.
     */
    mmsCampaignsByMmsCampaignIdPut(mmsCampaignId, campaign, options = {}) {
        const localVarPath = this.basePath + '/mms-campaigns/{mms_campaign_id}'
            .replace('{' + 'mms_campaign_id' + '}', encodeURIComponent(String(mmsCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mmsCampaignId' is not null or undefined
        if (mmsCampaignId === null || mmsCampaignId === undefined) {
            throw new Error('Required parameter mmsCampaignId was null or undefined when calling mmsCampaignsByMmsCampaignIdPut.');
        }
        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling mmsCampaignsByMmsCampaignIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "MmsCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel sms campaign
     * @summary Cancel mms campaign
     * @param mmsCampaignId ID of MMS Campaign to cancel
     * @param {*} [options] Override http request options.
     */
    mmsCampaignsCancelByMmsCampaignIdPut(mmsCampaignId, options = {}) {
        const localVarPath = this.basePath + '/mms-campaigns/{mms_campaign_id}/cancel'
            .replace('{' + 'mms_campaign_id' + '}', encodeURIComponent(String(mmsCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'mmsCampaignId' is not null or undefined
        if (mmsCampaignId === null || mmsCampaignId === undefined) {
            throw new Error('Required parameter mmsCampaignId was null or undefined when calling mmsCampaignsCancelByMmsCampaignIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of mms campaigns
     * @summary Get list of mms campaigns
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    mmsCampaignsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/mms-campaigns';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate price for sms campaign
     * @summary Calculate price for mms campaign
     * @param campaign MmsCampaign model
     * @param {*} [options] Override http request options.
     */
    mmsCampaignsPricePost(campaign, options = {}) {
        const localVarPath = this.basePath + '/mms-campaigns/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling mmsCampaignsPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "MmsCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create mms campaign
     * @summary Create mms campaign
     * @param campaign MmsCampaign model
     * @param {*} [options] Override http request options.
     */
    mmsCampaignsSendPost(campaign, options = {}) {
        const localVarPath = this.basePath + '/mms-campaigns/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling mmsCampaignsSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "MmsCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.MmsCampaignApi = MmsCampaignApi;
var NumberApiApiKeys;
(function (NumberApiApiKeys) {
})(NumberApiApiKeys = exports.NumberApiApiKeys || (exports.NumberApiApiKeys = {}));
class NumberApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[NumberApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Buy dedicated number
     * @summary Buy dedicated number
     * @param dedicatedNumber Phone number to purchase
     * @param {*} [options] Override http request options.
     */
    numbersBuyByDedicatedNumberPost(dedicatedNumber, options = {}) {
        const localVarPath = this.basePath + '/numbers/buy/{dedicated_number}'
            .replace('{' + 'dedicated_number' + '}', encodeURIComponent(String(dedicatedNumber)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'dedicatedNumber' is not null or undefined
        if (dedicatedNumber === null || dedicatedNumber === undefined) {
            throw new Error('Required parameter dedicatedNumber was null or undefined when calling numbersBuyByDedicatedNumberPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all availible dedicated numbers
     * @summary Get all availible dedicated numbers
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    numbersGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/numbers';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all dedicated numbers by country
     * @summary Get all dedicated numbers by country
     * @param country Country code to search
     * @param search Your search pattern or query.
     * @param searchType Your strategy for searching, 0 &#x3D; starts with, 1 &#x3D; anywhere, 2 &#x3D; ends with.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    numbersSearchByCountryGet(country, search, searchType, page, limit, options = {}) {
        const localVarPath = this.basePath + '/numbers/search/{country}'
            .replace('{' + 'country' + '}', encodeURIComponent(String(country)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
            throw new Error('Required parameter country was null or undefined when calling numbersSearchByCountryGet.');
        }
        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }
        if (searchType !== undefined) {
            localVarQueryParameters['search_type'] = ObjectSerializer.serialize(searchType, "number");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.NumberApi = NumberApi;
var PostLetterApiApiKeys;
(function (PostLetterApiApiKeys) {
})(PostLetterApiApiKeys = exports.PostLetterApiApiKeys || (exports.PostLetterApiApiKeys = {}));
class PostLetterApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PostLetterApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * export post letter history
     * @summary export post letter history
     * @param filename Filename to export to
     * @param {*} [options] Override http request options.
     */
    postLettersExportGet(filename, options = {}) {
        const localVarPath = this.basePath + '/post/letters/history/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'filename' is not null or undefined
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling postLettersExportGet.');
        }
        if (filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(filename, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all post letter history
     * @summary Get all post letter history
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    postLettersHistoryGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/post/letters/history';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate post letter price
     * @summary Calculate post letter price
     * @param postLetter PostLetter model
     * @param {*} [options] Override http request options.
     */
    postLettersPricePost(postLetter, options = {}) {
        const localVarPath = this.basePath + '/post/letters/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'postLetter' is not null or undefined
        if (postLetter === null || postLetter === undefined) {
            throw new Error('Required parameter postLetter was null or undefined when calling postLettersPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postLetter, "PostLetter")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send post letter
     * @summary Send post letter
     * @param postLetter PostLetter model
     * @param {*} [options] Override http request options.
     */
    postLettersSendPost(postLetter, options = {}) {
        const localVarPath = this.basePath + '/post/letters/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'postLetter' is not null or undefined
        if (postLetter === null || postLetter === undefined) {
            throw new Error('Required parameter postLetter was null or undefined when calling postLettersSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postLetter, "PostLetter")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PostLetterApi = PostLetterApi;
var PostPostcardApiApiKeys;
(function (PostPostcardApiApiKeys) {
})(PostPostcardApiApiKeys = exports.PostPostcardApiApiKeys || (exports.PostPostcardApiApiKeys = {}));
class PostPostcardApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PostPostcardApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Export postcard history to a CSV file
     * @summary Export postcard history to a CSV file
     * @param filename Filename to export to
     * @param {*} [options] Override http request options.
     */
    postPostcardsHistoryExportGet(filename, options = {}) {
        const localVarPath = this.basePath + '/post/postcards/history/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'filename' is not null or undefined
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling postPostcardsHistoryExportGet.');
        }
        if (filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(filename, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the history of postcards sent or scheduled
     * @summary Retrieve the history of postcards sent or scheduled
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    postPostcardsHistoryGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/post/postcards/history';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate price for sending one or more postcards
     * @summary Calculate price for sending one or more postcards
     * @param postPostcards PostPostcard model
     * @param {*} [options] Override http request options.
     */
    postPostcardsPricePost(postPostcards, options = {}) {
        const localVarPath = this.basePath + '/post/postcards/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'postPostcards' is not null or undefined
        if (postPostcards === null || postPostcards === undefined) {
            throw new Error('Required parameter postPostcards was null or undefined when calling postPostcardsPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postPostcards, "PostPostcard")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send one or more postcards
     * @summary Send one or more postcards
     * @param postPostcards PostPostcard model
     * @param {*} [options] Override http request options.
     */
    postPostcardsSendPost(postPostcards, options = {}) {
        const localVarPath = this.basePath + '/post/postcards/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'postPostcards' is not null or undefined
        if (postPostcards === null || postPostcards === undefined) {
            throw new Error('Required parameter postPostcards was null or undefined when calling postPostcardsSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postPostcards, "PostPostcard")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PostPostcardApi = PostPostcardApi;
var PostReturnAddressApiApiKeys;
(function (PostReturnAddressApiApiKeys) {
})(PostReturnAddressApiApiKeys = exports.PostReturnAddressApiApiKeys || (exports.PostReturnAddressApiApiKeys = {}));
class PostReturnAddressApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PostReturnAddressApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete specific post return address
     * @summary Delete specific post return address
     * @param returnAddressId Return address ID
     * @param {*} [options] Override http request options.
     */
    postReturnAddressesByReturnAddressIdDelete(returnAddressId, options = {}) {
        const localVarPath = this.basePath + '/post/return-addresses/{return_address_id}'
            .replace('{' + 'return_address_id' + '}', encodeURIComponent(String(returnAddressId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'returnAddressId' is not null or undefined
        if (returnAddressId === null || returnAddressId === undefined) {
            throw new Error('Required parameter returnAddressId was null or undefined when calling postReturnAddressesByReturnAddressIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific post return address
     * @summary Get specific post return address
     * @param returnAddressId Return address ID
     * @param {*} [options] Override http request options.
     */
    postReturnAddressesByReturnAddressIdGet(returnAddressId, options = {}) {
        const localVarPath = this.basePath + '/post/return-addresses/{return_address_id}'
            .replace('{' + 'return_address_id' + '}', encodeURIComponent(String(returnAddressId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'returnAddressId' is not null or undefined
        if (returnAddressId === null || returnAddressId === undefined) {
            throw new Error('Required parameter returnAddressId was null or undefined when calling postReturnAddressesByReturnAddressIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update post return address
     * @summary Update post return address
     * @param returnAddressId Return address ID
     * @param returnAddress Address model
     * @param {*} [options] Override http request options.
     */
    postReturnAddressesByReturnAddressIdPut(returnAddressId, returnAddress, options = {}) {
        const localVarPath = this.basePath + '/post/return-addresses/{return_address_id}'
            .replace('{' + 'return_address_id' + '}', encodeURIComponent(String(returnAddressId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'returnAddressId' is not null or undefined
        if (returnAddressId === null || returnAddressId === undefined) {
            throw new Error('Required parameter returnAddressId was null or undefined when calling postReturnAddressesByReturnAddressIdPut.');
        }
        // verify required parameter 'returnAddress' is not null or undefined
        if (returnAddress === null || returnAddress === undefined) {
            throw new Error('Required parameter returnAddress was null or undefined when calling postReturnAddressesByReturnAddressIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(returnAddress, "Address")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of post return addresses
     * @summary Get list of post return addresses
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    postReturnAddressesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/post/return-addresses';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create post return address
     * @summary Create post return address
     * @param returnAddress Address model
     * @param {*} [options] Override http request options.
     */
    postReturnAddressesPost(returnAddress, options = {}) {
        const localVarPath = this.basePath + '/post/return-addresses';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'returnAddress' is not null or undefined
        if (returnAddress === null || returnAddress === undefined) {
            throw new Error('Required parameter returnAddress was null or undefined when calling postReturnAddressesPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(returnAddress, "Address")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PostReturnAddressApi = PostReturnAddressApi;
var ReferralAccountApiApiKeys;
(function (ReferralAccountApiApiKeys) {
})(ReferralAccountApiApiKeys = exports.ReferralAccountApiApiKeys || (exports.ReferralAccountApiApiKeys = {}));
class ReferralAccountApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ReferralAccountApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get all referral accounts
     * @summary Get all referral accounts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    referralAccountsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/referral/accounts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ReferralAccountApi = ReferralAccountApi;
var ResellerAccountApiApiKeys;
(function (ResellerAccountApiApiKeys) {
})(ResellerAccountApiApiKeys = exports.ResellerAccountApiApiKeys || (exports.ResellerAccountApiApiKeys = {}));
class ResellerAccountApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ResellerAccountApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get Reseller clients Account
     * @summary Get Reseller clients Account
     * @param clientUserId User ID of client
     * @param {*} [options] Override http request options.
     */
    resellerAccountsByClientUserIdGet(clientUserId, options = {}) {
        const localVarPath = this.basePath + '/reseller/accounts/{client_user_id}'
            .replace('{' + 'client_user_id' + '}', encodeURIComponent(String(clientUserId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientUserId' is not null or undefined
        if (clientUserId === null || clientUserId === undefined) {
            throw new Error('Required parameter clientUserId was null or undefined when calling resellerAccountsByClientUserIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Reseller clients Account
     * @summary Update Reseller clients Account
     * @param clientUserId User ID of client
     * @param resellerAccount ResellerAccount model
     * @param {*} [options] Override http request options.
     */
    resellerAccountsByClientUserIdPut(clientUserId, resellerAccount, options = {}) {
        const localVarPath = this.basePath + '/reseller/accounts/{client_user_id}'
            .replace('{' + 'client_user_id' + '}', encodeURIComponent(String(clientUserId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientUserId' is not null or undefined
        if (clientUserId === null || clientUserId === undefined) {
            throw new Error('Required parameter clientUserId was null or undefined when calling resellerAccountsByClientUserIdPut.');
        }
        // verify required parameter 'resellerAccount' is not null or undefined
        if (resellerAccount === null || resellerAccount === undefined) {
            throw new Error('Required parameter resellerAccount was null or undefined when calling resellerAccountsByClientUserIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerAccount, "ResellerAccount")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of reseller accounts
     * @summary Get list of reseller accounts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    resellerAccountsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/reseller/accounts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create reseller account
     * @summary Create reseller account
     * @param resellerAccount ResellerAccount model
     * @param {*} [options] Override http request options.
     */
    resellerAccountsPost(resellerAccount, options = {}) {
        const localVarPath = this.basePath + '/reseller/accounts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'resellerAccount' is not null or undefined
        if (resellerAccount === null || resellerAccount === undefined) {
            throw new Error('Required parameter resellerAccount was null or undefined when calling resellerAccountsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerAccount, "ResellerAccount")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ResellerAccountApi = ResellerAccountApi;
var SMSApiApiKeys;
(function (SMSApiApiKeys) {
})(SMSApiApiKeys = exports.SMSApiApiKeys || (exports.SMSApiApiKeys = {}));
class SMSApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SMSApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Update all scheduled message as cancelled
     * @summary Update all scheduled message as cancelled
     * @param {*} [options] Override http request options.
     */
    smsCancelAllPut(options = {}) {
        const localVarPath = this.basePath + '/sms/cancel-all';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update scheduled message as cancelled
     * @summary Update scheduled message as cancelled
     * @param messageId The message ID you want to cancel
     * @param {*} [options] Override http request options.
     */
    smsCancelByMessageIdPut(messageId, options = {}) {
        const localVarPath = this.basePath + '/sms/{message_id}/cancel'
            .replace('{' + 'message_id' + '}', encodeURIComponent(String(messageId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling smsCancelByMessageIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export all sms history
     * @summary Export all sms history
     * @param filename Filename to download history as
     * @param {*} [options] Override http request options.
     */
    smsHistoryExportGet(filename, options = {}) {
        const localVarPath = this.basePath + '/sms/history/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'filename' is not null or undefined
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling smsHistoryExportGet.');
        }
        if (filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(filename, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all sms history
     * @summary Get all sms history
     * @param q Custom query Example: from:{number},status_code:201.
     * @param dateFrom Start date
     * @param dateTo End date
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsHistoryGet(q, dateFrom, dateTo, page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms/history';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all inbound sms
     * @summary Get all inbound sms
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsInboundGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms/inbound';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create inbound sms
     * @summary Create inbound sms
     * @param url Url model
     * @param {*} [options] Override http request options.
     */
    smsInboundPost(url, options = {}) {
        const localVarPath = this.basePath + '/sms/inbound';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling smsInboundPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(url, "Url")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark specific inbound SMS as read
     * @summary Mark inbound SMS as read
     * @param messageId Message ID
     * @param {*} [options] Override http request options.
     */
    smsInboundReadByMessageIdPut(messageId, options = {}) {
        const localVarPath = this.basePath + '/sms/inbound-read/{message_id}'
            .replace('{' + 'message_id' + '}', encodeURIComponent(String(messageId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling smsInboundReadByMessageIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark all inbound SMS as read optionally before a certain date
     * @summary Mark inbound SMS as read
     * @param dateBefore DateBefore model
     * @param {*} [options] Override http request options.
     */
    smsInboundReadPut(dateBefore, options = {}) {
        const localVarPath = this.basePath + '/sms/inbound-read';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dateBefore, "DateBefore")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate sms price
     * @summary Calculate sms price
     * @param smsMessages SmsMessageCollection model
     * @param {*} [options] Override http request options.
     */
    smsPricePost(smsMessages, options = {}) {
        const localVarPath = this.basePath + '/sms/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'smsMessages' is not null or undefined
        if (smsMessages === null || smsMessages === undefined) {
            throw new Error('Required parameter smsMessages was null or undefined when calling smsPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smsMessages, "SmsMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Specific Delivery Receipt
     * @summary Get a Specific Delivery Receipt
     * @param messageId Message ID
     * @param {*} [options] Override http request options.
     */
    smsReceiptsByMessageIdGet(messageId, options = {}) {
        const localVarPath = this.basePath + '/sms/receipts/{message_id}'
            .replace('{' + 'message_id' + '}', encodeURIComponent(String(messageId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling smsReceiptsByMessageIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all delivery receipts
     * @summary Get all delivery receipts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsReceiptsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a delivery receipt
     * @summary Add a delivery receipt
     * @param url Url model
     * @param {*} [options] Override http request options.
     */
    smsReceiptsPost(url, options = {}) {
        const localVarPath = this.basePath + '/sms/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling smsReceiptsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(url, "Url")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark delivery receipts as read
     * @summary Mark delivery receipts as read
     * @param dateBefore DateBefore model
     * @param {*} [options] Override http request options.
     */
    smsReceiptsReadPut(dateBefore, options = {}) {
        const localVarPath = this.basePath + '/sms/receipts-read';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dateBefore, "DateBefore")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *  # Send one or more SMS messages  You can post up to 1000 messages with each API call. You can send to a mix of contacts and contact lists, as long as the total number of recipients is up to 1000.  The response contains status and details for each recipient.  *Refer to [Application Status Codes](https://dashboard.clicksend.com/#/signup/step1/) for the possible response message status strings.*
     * @summary Send sms message(s)
     * @param smsMessages SmsMessageCollection model
     * @param {*} [options] Override http request options.
     */
    smsSendPost(smsMessages, options = {}) {
        const localVarPath = this.basePath + '/sms/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'smsMessages' is not null or undefined
        if (smsMessages === null || smsMessages === undefined) {
            throw new Error('Required parameter smsMessages was null or undefined when calling smsSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smsMessages, "SmsMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete sms template
     * @summary Delete sms template
     * @param templateId Template id
     * @param {*} [options] Override http request options.
     */
    smsTemplatesByTemplateIdDelete(templateId, options = {}) {
        const localVarPath = this.basePath + '/sms/templates/{template_id}'
            .replace('{' + 'template_id' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling smsTemplatesByTemplateIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update sms template
     * @summary Update sms template
     * @param templateId Template id
     * @param smsTemplate Template item
     * @param {*} [options] Override http request options.
     */
    smsTemplatesByTemplateIdPut(templateId, smsTemplate, options = {}) {
        const localVarPath = this.basePath + '/sms/templates/{template_id}'
            .replace('{' + 'template_id' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling smsTemplatesByTemplateIdPut.');
        }
        // verify required parameter 'smsTemplate' is not null or undefined
        if (smsTemplate === null || smsTemplate === undefined) {
            throw new Error('Required parameter smsTemplate was null or undefined when calling smsTemplatesByTemplateIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smsTemplate, "SmsTemplate")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get lists of all sms templates
     * @summary Get lists of all sms templates
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsTemplatesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms/templates';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create sms template
     * @summary Create sms template
     * @param smsTemplate SmsTemplate model
     * @param {*} [options] Override http request options.
     */
    smsTemplatesPost(smsTemplate, options = {}) {
        const localVarPath = this.basePath + '/sms/templates';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'smsTemplate' is not null or undefined
        if (smsTemplate === null || smsTemplate === undefined) {
            throw new Error('Required parameter smsTemplate was null or undefined when calling smsTemplatesPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(smsTemplate, "SmsTemplate")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SMSApi = SMSApi;
var SMSDeliveryReceiptRulesApiApiKeys;
(function (SMSDeliveryReceiptRulesApiApiKeys) {
})(SMSDeliveryReceiptRulesApiApiKeys = exports.SMSDeliveryReceiptRulesApiApiKeys || (exports.SMSDeliveryReceiptRulesApiApiKeys = {}));
class SMSDeliveryReceiptRulesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SMSDeliveryReceiptRulesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete sms delivery receipt automation
     * @summary Delete sms delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    smsDeliveryReceiptAutomationDelete(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling smsDeliveryReceiptAutomationDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific sms delivery receipt automation
     * @summary Get specific sms delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    smsDeliveryReceiptAutomationGet(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling smsDeliveryReceiptAutomationGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create sms delivery receipt automations
     * @summary Create sms delivery receipt automations
     * @param deliveryReceiptRule sms delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    smsDeliveryReceiptAutomationPost(deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling smsDeliveryReceiptAutomationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update sms delivery receipt automation
     * @summary Update sms delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param deliveryReceiptRule Delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    smsDeliveryReceiptAutomationPut(receiptRuleId, deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling smsDeliveryReceiptAutomationPut.');
        }
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling smsDeliveryReceiptAutomationPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all sms delivery receipt automations
     * @summary Get all sms delivery receipt automations
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsDeliveryReceiptAutomationsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/automations/sms/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SMSDeliveryReceiptRulesApi = SMSDeliveryReceiptRulesApi;
var SearchApiApiKeys;
(function (SearchApiApiKeys) {
})(SearchApiApiKeys = exports.SearchApiApiKeys || (exports.SearchApiApiKeys = {}));
class SearchApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SearchApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get list of searched contact list
     * @summary Get list of searched contact list
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    searchContactsListsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/search/contacts-lists';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchContactsListsGet.');
        }
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SearchApi = SearchApi;
var SmsCampaignApiApiKeys;
(function (SmsCampaignApiApiKeys) {
})(SmsCampaignApiApiKeys = exports.SmsCampaignApiApiKeys || (exports.SmsCampaignApiApiKeys = {}));
class SmsCampaignApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SmsCampaignApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get specific sms campaign
     * @summary Get specific sms campaign
     * @param smsCampaignId ID of SMS campaign to retrieve
     * @param {*} [options] Override http request options.
     */
    smsCampaignBySmsCampaignIdGet(smsCampaignId, options = {}) {
        const localVarPath = this.basePath + '/sms-campaigns/{sms_campaign_id}'
            .replace('{' + 'sms_campaign_id' + '}', encodeURIComponent(String(smsCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'smsCampaignId' is not null or undefined
        if (smsCampaignId === null || smsCampaignId === undefined) {
            throw new Error('Required parameter smsCampaignId was null or undefined when calling smsCampaignBySmsCampaignIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update sms campaign
     * @summary Update sms campaign
     * @param smsCampaignId ID of SMS campaign to update
     * @param campaign SmsCampaign model
     * @param {*} [options] Override http request options.
     */
    smsCampaignsBySmsCampaignIdPut(smsCampaignId, campaign, options = {}) {
        const localVarPath = this.basePath + '/sms-campaigns/{sms_campaign_id}'
            .replace('{' + 'sms_campaign_id' + '}', encodeURIComponent(String(smsCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'smsCampaignId' is not null or undefined
        if (smsCampaignId === null || smsCampaignId === undefined) {
            throw new Error('Required parameter smsCampaignId was null or undefined when calling smsCampaignsBySmsCampaignIdPut.');
        }
        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling smsCampaignsBySmsCampaignIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "SmsCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel sms campaign
     * @summary Cancel sms campaign
     * @param smsCampaignId ID of SMS Campaign to cancel
     * @param {*} [options] Override http request options.
     */
    smsCampaignsCancelBySmsCampaignIdPut(smsCampaignId, options = {}) {
        const localVarPath = this.basePath + '/sms-campaigns/{sms_campaign_id}/cancel'
            .replace('{' + 'sms_campaign_id' + '}', encodeURIComponent(String(smsCampaignId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'smsCampaignId' is not null or undefined
        if (smsCampaignId === null || smsCampaignId === undefined) {
            throw new Error('Required parameter smsCampaignId was null or undefined when calling smsCampaignsCancelBySmsCampaignIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of sms campaigns
     * @summary Get list of sms campaigns
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    smsCampaignsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/sms-campaigns';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate price for sms campaign
     * @summary Calculate price for sms campaign
     * @param campaign SmsCampaign model
     * @param {*} [options] Override http request options.
     */
    smsCampaignsPricePost(campaign, options = {}) {
        const localVarPath = this.basePath + '/sms-campaigns/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling smsCampaignsPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "SmsCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create sms campaign
     * @summary Create sms campaign
     * @param campaign SmsCampaign model
     * @param {*} [options] Override http request options.
     */
    smsCampaignsSendPost(campaign, options = {}) {
        const localVarPath = this.basePath + '/sms-campaigns/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'campaign' is not null or undefined
        if (campaign === null || campaign === undefined) {
            throw new Error('Required parameter campaign was null or undefined when calling smsCampaignsSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(campaign, "SmsCampaign")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SmsCampaignApi = SmsCampaignApi;
var StatisticsApiApiKeys;
(function (StatisticsApiApiKeys) {
})(StatisticsApiApiKeys = exports.StatisticsApiApiKeys || (exports.StatisticsApiApiKeys = {}));
class StatisticsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[StatisticsApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get sms statistics
     * @summary Get sms statistics
     * @param {*} [options] Override http request options.
     */
    statisticsSmsGet(options = {}) {
        const localVarPath = this.basePath + '/statistics/sms';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get voice statistics
     * @summary Get voice statistics
     * @param {*} [options] Override http request options.
     */
    statisticsVoiceGet(options = {}) {
        const localVarPath = this.basePath + '/statistics/voice';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.StatisticsApi = StatisticsApi;
var SubaccountApiApiKeys;
(function (SubaccountApiApiKeys) {
})(SubaccountApiApiKeys = exports.SubaccountApiApiKeys || (exports.SubaccountApiApiKeys = {}));
class SubaccountApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SubaccountApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete a subaccount
     * @summary Delete a subaccount
     * @param subaccountId ID of subaccount to delete
     * @param {*} [options] Override http request options.
     */
    subaccountsBySubaccountIdDelete(subaccountId, options = {}) {
        const localVarPath = this.basePath + '/subaccounts/{subaccount_id}'
            .replace('{' + 'subaccount_id' + '}', encodeURIComponent(String(subaccountId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling subaccountsBySubaccountIdDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific subaccount
     * @summary Get specific subaccount
     * @param subaccountId ID of subaccount to get
     * @param {*} [options] Override http request options.
     */
    subaccountsBySubaccountIdGet(subaccountId, options = {}) {
        const localVarPath = this.basePath + '/subaccounts/{subaccount_id}'
            .replace('{' + 'subaccount_id' + '}', encodeURIComponent(String(subaccountId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling subaccountsBySubaccountIdGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update subaccount
     * @summary Update subaccount
     * @param subaccountId ID of subaccount to update
     * @param subaccount Subaccount model
     * @param {*} [options] Override http request options.
     */
    subaccountsBySubaccountIdPut(subaccountId, subaccount, options = {}) {
        const localVarPath = this.basePath + '/subaccounts/{subaccount_id}'
            .replace('{' + 'subaccount_id' + '}', encodeURIComponent(String(subaccountId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling subaccountsBySubaccountIdPut.');
        }
        // verify required parameter 'subaccount' is not null or undefined
        if (subaccount === null || subaccount === undefined) {
            throw new Error('Required parameter subaccount was null or undefined when calling subaccountsBySubaccountIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subaccount, "Subaccount")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all subaccounts
     * @summary Get all subaccounts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    subaccountsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/subaccounts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create new subaccount
     * @summary Create new subaccount
     * @param subaccount Subaccount model
     * @param {*} [options] Override http request options.
     */
    subaccountsPost(subaccount, options = {}) {
        const localVarPath = this.basePath + '/subaccounts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'subaccount' is not null or undefined
        if (subaccount === null || subaccount === undefined) {
            throw new Error('Required parameter subaccount was null or undefined when calling subaccountsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subaccount, "Subaccount")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Regenerate an API Key
     * @summary Regenerate an API Key
     * @param subaccountId ID of subaccount to regenerate API key for
     * @param {*} [options] Override http request options.
     */
    subaccountsRegenApiKeyBySubaccountIdPut(subaccountId, options = {}) {
        const localVarPath = this.basePath + '/subaccounts/{subaccount_id}/regen-api-key'
            .replace('{' + 'subaccount_id' + '}', encodeURIComponent(String(subaccountId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'subaccountId' is not null or undefined
        if (subaccountId === null || subaccountId === undefined) {
            throw new Error('Required parameter subaccountId was null or undefined when calling subaccountsRegenApiKeyBySubaccountIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SubaccountApi = SubaccountApi;
var TimezonesApiApiKeys;
(function (TimezonesApiApiKeys) {
})(TimezonesApiApiKeys = exports.TimezonesApiApiKeys || (exports.TimezonesApiApiKeys = {}));
class TimezonesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[TimezonesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Get supported list of timezones.
     * @summary Get supported list of timezones.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    timezonesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/timezones';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.TimezonesApi = TimezonesApi;
var TransactionalEmailApiApiKeys;
(function (TransactionalEmailApiApiKeys) {
})(TransactionalEmailApiApiKeys = exports.TransactionalEmailApiApiKeys || (exports.TransactionalEmailApiApiKeys = {}));
class TransactionalEmailApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[TransactionalEmailApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Export all Transactional Email history
     * @summary Export all Transactional Email history
     * @param filename Filename to download history as
     * @param dateFrom Start date
     * @param dateTo End date
     * @param {*} [options] Override http request options.
     */
    emailHistoryExportGet(filename, dateFrom, dateTo, options = {}) {
        const localVarPath = this.basePath + '/email/history/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'filename' is not null or undefined
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling emailHistoryExportGet.');
        }
        if (filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(filename, "string");
        }
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all transactional email history
     * @summary Get all transactional email history
     * @param dateFrom Start date
     * @param dateTo End date
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    emailHistoryGet(dateFrom, dateTo, page, limit, options = {}) {
        const localVarPath = this.basePath + '/email/history';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get transactional email price
     * @summary Get transactional email price
     * @param email Email model
     * @param {*} [options] Override http request options.
     */
    emailPricePost(email, options = {}) {
        const localVarPath = this.basePath + '/email/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling emailPricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(email, "Email")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send transactional email
     * @summary Send transactional email
     * @param email Email model
     * @param {*} [options] Override http request options.
     */
    emailSendPost(email, options = {}) {
        const localVarPath = this.basePath + '/email/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling emailSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(email, "Email")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.TransactionalEmailApi = TransactionalEmailApi;
var TransferCreditApiApiKeys;
(function (TransferCreditApiApiKeys) {
})(TransferCreditApiApiKeys = exports.TransferCreditApiApiKeys || (exports.TransferCreditApiApiKeys = {}));
class TransferCreditApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[TransferCreditApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Transfer Credit
     * @summary Transfer Credit
     * @param resellerAccountTransferCredit ResellerAccountTransferCredit model
     * @param {*} [options] Override http request options.
     */
    resellerTransferCreditPut(resellerAccountTransferCredit, options = {}) {
        const localVarPath = this.basePath + '/reseller/transfer-credit';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'resellerAccountTransferCredit' is not null or undefined
        if (resellerAccountTransferCredit === null || resellerAccountTransferCredit === undefined) {
            throw new Error('Required parameter resellerAccountTransferCredit was null or undefined when calling resellerTransferCreditPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerAccountTransferCredit, "ResellerAccountTransferCredit")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.TransferCreditApi = TransferCreditApi;
var UploadApiApiKeys;
(function (UploadApiApiKeys) {
})(UploadApiApiKeys = exports.UploadApiApiKeys || (exports.UploadApiApiKeys = {}));
class UploadApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[UploadApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Upload File
     * @summary Upload File
     * @param uploadFile Your file to be uploaded
     * @param convert
     * @param {*} [options] Override http request options.
     */
    uploadsPost(uploadFile, convert, options = {}) {
        const localVarPath = this.basePath + '/uploads';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'uploadFile' is not null or undefined
        if (uploadFile === null || uploadFile === undefined) {
            throw new Error('Required parameter uploadFile was null or undefined when calling uploadsPost.');
        }
        // verify required parameter 'convert' is not null or undefined
        if (convert === null || convert === undefined) {
            throw new Error('Required parameter convert was null or undefined when calling uploadsPost.');
        }
        if (convert !== undefined) {
            localVarQueryParameters['convert'] = ObjectSerializer.serialize(convert, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uploadFile, "UploadFile")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.UploadApi = UploadApi;
var UserEmailTemplatesApiApiKeys;
(function (UserEmailTemplatesApiApiKeys) {
})(UserEmailTemplatesApiApiKeys = exports.UserEmailTemplatesApiApiKeys || (exports.UserEmailTemplatesApiApiKeys = {}));
class UserEmailTemplatesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[UserEmailTemplatesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete user email template
     * @summary Delete user email template
     * @param templateId Email template id
     * @param {*} [options] Override http request options.
     */
    emailTemplateDelete(templateId, options = {}) {
        const localVarPath = this.basePath + '/email/templates/{template_id}'
            .replace('{' + 'template_id' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling emailTemplateDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific user email templates
     * @summary Get specific user email template
     * @param templateId Email template id
     * @param {*} [options] Override http request options.
     */
    emailTemplateGet(templateId, options = {}) {
        const localVarPath = this.basePath + '/email/templates/{template_id}'
            .replace('{' + 'template_id' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling emailTemplateGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create email template
     * @summary Create email template
     * @param emailTemplate Email template model
     * @param {*} [options] Override http request options.
     */
    emailTemplatePost(emailTemplate, options = {}) {
        const localVarPath = this.basePath + '/email/templates';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'emailTemplate' is not null or undefined
        if (emailTemplate === null || emailTemplate === undefined) {
            throw new Error('Required parameter emailTemplate was null or undefined when calling emailTemplatePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailTemplate, "EmailTemplateNew")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email template
     * @summary Update email template
     * @param templateId Email template id
     * @param emailTemplate Email template model
     * @param {*} [options] Override http request options.
     */
    emailTemplatePut(templateId, emailTemplate, options = {}) {
        const localVarPath = this.basePath + '/email/templates/{template_id}'
            .replace('{' + 'template_id' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling emailTemplatePut.');
        }
        // verify required parameter 'emailTemplate' is not null or undefined
        if (emailTemplate === null || emailTemplate === undefined) {
            throw new Error('Required parameter emailTemplate was null or undefined when calling emailTemplatePut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailTemplate, "EmailTemplateUpdate")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all user email templates
     * @summary Get all user email templates
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    emailTemplatesGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/email/templates';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.UserEmailTemplatesApi = UserEmailTemplatesApi;
var VoiceApiApiKeys;
(function (VoiceApiApiKeys) {
})(VoiceApiApiKeys = exports.VoiceApiApiKeys || (exports.VoiceApiApiKeys = {}));
class VoiceApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[VoiceApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Update all voice messages as cancelled
     * @summary Update all voice messages as cancelled
     * @param {*} [options] Override http request options.
     */
    voiceCancelAllPut(options = {}) {
        const localVarPath = this.basePath + '/voice/cancel-all';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update voice message status as cancelled
     * @summary Update voice message status as cancelled
     * @param messageId Your voice message id
     * @param {*} [options] Override http request options.
     */
    voiceCancelByMessageIdPut(messageId, options = {}) {
        const localVarPath = this.basePath + '/voice/{message_id}/cancel'
            .replace('{' + 'message_id' + '}', encodeURIComponent(String(messageId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'messageId' is not null or undefined
        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling voiceCancelByMessageIdPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export voice history
     * @summary Export voice history
     * @param filename Filename to export to
     * @param {*} [options] Override http request options.
     */
    voiceHistoryExportGet(filename, options = {}) {
        const localVarPath = this.basePath + '/voice/history/export';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'filename' is not null or undefined
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling voiceHistoryExportGet.');
        }
        if (filename !== undefined) {
            localVarQueryParameters['filename'] = ObjectSerializer.serialize(filename, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all voice history
     * @summary Get all voice history
     * @param dateFrom Timestamp (from) used to show records by date.
     * @param dateTo Timestamp (to) used to show records by date
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    voiceHistoryGet(dateFrom, dateTo, page, limit, options = {}) {
        const localVarPath = this.basePath + '/voice/history';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (dateFrom !== undefined) {
            localVarQueryParameters['date_from'] = ObjectSerializer.serialize(dateFrom, "number");
        }
        if (dateTo !== undefined) {
            localVarQueryParameters['date_to'] = ObjectSerializer.serialize(dateTo, "number");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all voice languages
     * @summary Get all voice languages
     * @param {*} [options] Override http request options.
     */
    voiceLangGet(options = {}) {
        const localVarPath = this.basePath + '/voice/lang';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculate voice price
     * @summary Calculate voice price
     * @param voiceMessages VoiceMessageCollection model
     * @param {*} [options] Override http request options.
     */
    voicePricePost(voiceMessages, options = {}) {
        const localVarPath = this.basePath + '/voice/price';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'voiceMessages' is not null or undefined
        if (voiceMessages === null || voiceMessages === undefined) {
            throw new Error('Required parameter voiceMessages was null or undefined when calling voicePricePost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voiceMessages, "VoiceMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all delivery receipts
     * @summary Get all delivery receipts
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    voiceReceiptsGet(page, limit, options = {}) {
        const localVarPath = this.basePath + '/voice/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a delivery receipt
     * @summary Add a delivery receipt
     * @param url Url model
     * @param {*} [options] Override http request options.
     */
    voiceReceiptsPost(url, options = {}) {
        const localVarPath = this.basePath + '/voice/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling voiceReceiptsPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(url, "Url")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark delivery receipts as read
     * @summary Mark delivery receipts as read
     * @param dateBefore DateBefore model
     * @param {*} [options] Override http request options.
     */
    voiceReceiptsReadPut(dateBefore, options = {}) {
        const localVarPath = this.basePath + '/voice/receipts-read';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dateBefore, "DateBefore")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send a voice call
     * @summary Send voice message(s)
     * @param voiceMessages VoiceMessageCollection model
     * @param {*} [options] Override http request options.
     */
    voiceSendPost(voiceMessages, options = {}) {
        const localVarPath = this.basePath + '/voice/send';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'voiceMessages' is not null or undefined
        if (voiceMessages === null || voiceMessages === undefined) {
            throw new Error('Required parameter voiceMessages was null or undefined when calling voiceSendPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voiceMessages, "VoiceMessageCollection")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.VoiceApi = VoiceApi;
var VoiceDeliveryReceiptRulesApiApiKeys;
(function (VoiceDeliveryReceiptRulesApiApiKeys) {
})(VoiceDeliveryReceiptRulesApiApiKeys = exports.VoiceDeliveryReceiptRulesApiApiKeys || (exports.VoiceDeliveryReceiptRulesApiApiKeys = {}));
class VoiceDeliveryReceiptRulesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'BasicAuth': new HttpBasicAuth(),
        };
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[VoiceDeliveryReceiptRulesApiApiKeys[key]].apiKey = value;
    }
    set username(username) {
        this.authentications.BasicAuth.username = username;
    }
    set password(password) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * Delete voice delivery receipt automation
     * @summary Delete voice delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    voiceDeliveryReceiptAutomationDelete(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/voice/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling voiceDeliveryReceiptAutomationDelete.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get specific voice delivery receipt automation
     * @summary Get specific voice delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param {*} [options] Override http request options.
     */
    voiceDeliveryReceiptAutomationGet(receiptRuleId, options = {}) {
        const localVarPath = this.basePath + '/automations/voice/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling voiceDeliveryReceiptAutomationGet.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create voice delivery receipt automations
     * @summary Create voice delivery receipt automations
     * @param deliveryReceiptRule voice delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    voiceDeliveryReceiptAutomationPost(deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/voice/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling voiceDeliveryReceiptAutomationPost.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update voice delivery receipt automation
     * @summary Update voice delivery receipt automation
     * @param receiptRuleId Receipt rule id
     * @param deliveryReceiptRule Delivery receipt rule model
     * @param {*} [options] Override http request options.
     */
    voiceDeliveryReceiptAutomationPut(receiptRuleId, deliveryReceiptRule, options = {}) {
        const localVarPath = this.basePath + '/automations/voice/receipts/{receipt_rule_id}'
            .replace('{' + 'receipt_rule_id' + '}', encodeURIComponent(String(receiptRuleId)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'receiptRuleId' is not null or undefined
        if (receiptRuleId === null || receiptRuleId === undefined) {
            throw new Error('Required parameter receiptRuleId was null or undefined when calling voiceDeliveryReceiptAutomationPut.');
        }
        // verify required parameter 'deliveryReceiptRule' is not null or undefined
        if (deliveryReceiptRule === null || deliveryReceiptRule === undefined) {
            throw new Error('Required parameter deliveryReceiptRule was null or undefined when calling voiceDeliveryReceiptAutomationPut.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deliveryReceiptRule, "DeliveryReceiptRule")
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all voice delivery receipt automations
     * @summary Get all voice delivery receipt automations
     * @param q Your keyword or query.
     * @param page Page number
     * @param limit Number of records per page
     * @param {*} [options] Override http request options.
     */
    voiceDeliveryReceiptAutomationsGet(q, page, limit, options = {}) {
        const localVarPath = this.basePath + '/automations/voice/receipts';
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }
        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.VoiceDeliveryReceiptRulesApi = VoiceDeliveryReceiptRulesApi;
//# sourceMappingURL=api.js.map